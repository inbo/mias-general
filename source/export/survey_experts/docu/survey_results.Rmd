---
title: "Results expert survey on invasive alien species"
author: "Janne Adolf"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "../../../../output/survey_experts") })
---

<!----------------------------------------------------------------------->
<!---- setup ------------------------------------------------------------>
<!----------------------------------------------------------------------->


```{r setup, include = FALSE}

rm(list = ls())

knitr::opts_chunk$set(echo = FALSE, message = FALSE)

list.files("../../../functions", full.names = TRUE) |>
  lapply(source) |>
  invisible()

# language
lang <- "NL"

# ADAPT: use english q's
questions_path <- if (lang == "NL") {
  "../questions_NL/"
} else if (lang == "EN"){
  "../questions_EN/"
}

# path to locally saved processed response data 
response_data_path <- "../../../../data/survey_experts/"

# fig dim
fig_w <- 10
fig_h <- 10


# check whether y-axis labels are always correct


```

<!----------------------------------------------------------------------->
<!---- prepare response data -------------------------------------------->
<!----------------------------------------------------------------------->

```{r prep-data}

# response data 
# current version: 17-02-2025
load(paste0(response_data_path, "results_combined_upd.rda"))
#
# define subsets of response data

res_scored_allspec <- res_comb_upd |>
  dplyr::filter(question_scored |> as.logical(), !section_skipped) |>
  dplyr::filter(!grepl("IRR", prius_stadium)) 
res_scored <- res_scored_allspec |>
  dplyr::filter(on_unionlist) 
res_open <- res_comb_upd |>
  dplyr::filter(!question_scored |> as.logical(), !section_skipped) |>
  dplyr::filter(on_unionlist, !grepl("IRR", prius_stadium))

```

<!----------------------------------------------------------------------->
<!---- setup functions -------------------------------------------------->
<!----------------------------------------------------------------------->

```{r setup-functions}

# mean function
summarize <- function(
    res,
    crit,
    group_by_what = "species",
    fun = "mean"
){
  res_mean <- res |>
    dplyr::filter(
      grepl(crit, score_crit)
    ) |>
    # fun output per group
    dplyr::group_by(dplyr::across(tidyselect::all_of(group_by_what))) |>
    dplyr::mutate(m = do.call(fun, list(response_score, na.rm = TRUE))) |>
    dplyr::filter(dplyr::row_number() == 1) |>
    dplyr::ungroup() |>
    # fun output of fun output
    dplyr::mutate(m = do.call(fun, list(m)), .by = species) |>
    dplyr::distinct(species, .keep_all = TRUE) |>
    #
    dplyr::select(tidyselect::starts_with(c("species","stadium","m","on_union", "vern"))) |>
    dplyr::arrange(dplyr::desc(m)) |>
    dplyr::rename_with(~ paste0("m_", crit), "m")
}
#
# function to factorize variables
factorize <- function(
    res,
    varnames,
    varlevels
) {
  for (i in seq_along(varnames)) {
    res  <- res  |>
      dplyr::mutate(
        !!varnames[i] := factor(get(varnames[i]), levels = varlevels[[i]])
      )
  }
  return(res)
}
#
# function to highlight labels
highlight_labs <- function(
    labs,
    pattern,
    color = "black"
){
  tmpdata <- data.frame(labs = labs)|>
    dplyr::mutate(
      labs_hl := dplyr::case_when(
        grepl(pattern, labs) ~ glue::glue(
          "<span style = 'color:{color}'>**{labs}**</span>"),
        TRUE ~ labs
      )
    ) |>
    dplyr::pull(labs_hl)
}

```

<!----------------------------------------------------------------------->
<!---- calculate mean scores and rank ----------------------------------->
<!----------------------------------------------------------------------->

```{r mean-ranking, results = 'hide'}

# grand means urgency & feasibility
res_m_feas <- summarize(res_scored_allspec, "feas")
res_m_urge <- summarize(res_scored_allspec, "urge")
# grand mean all questions
res_m_feasurge <- summarize(res_scored_allspec, "feas|urge")
# section group means urgency & feasibility
res_gm_feas <- summarize(res_scored_allspec, "feas", group_by_what = c("species", "section_no"))
res_gm_urge <- summarize(res_scored_allspec, "urge", group_by_what = c("species", "section_no"))
# grand median all questions
res_med_feasurge <- summarize(res_scored_allspec, "feas|urge", fun = "median")

# merge data
res_m_allspec <- dplyr::full_join(
  x = res_m_feas,
  y = res_m_urge
) |>
  dplyr::full_join(
    x = _,
    y = res_m_feasurge |> dplyr::rename(m_feasurge = "m_feas|urge")
  ) |>
  dplyr::full_join(
    x = _,
    y = res_gm_feas |> dplyr::rename(gm_feas = "m_feas")
  ) |>
  dplyr::full_join(
    x = _,
    y = res_gm_urge |> dplyr::rename(gm_urge = "m_urge")
  ) |>
  dplyr::mutate(
    gm_mfeas_murge = mean(c(m_feas, m_urge)),
    .by = species
  ) |>
  dplyr::mutate(
    gm_gmfeas_gmurge = mean(c(gm_feas, gm_urge)),
    .by = species
  ) |>
  dplyr::arrange(dplyr::desc(m_feasurge))
#
# correlations of different means
cor(res_m_allspec |> dplyr::select(tidyselect::contains(c("m_"))))
#
# keep only species on unionlist
res_m <- res_m_allspec |>
  dplyr::filter(on_unionlist) 

```

<!----------------------------------------------------------------------->
<!---- define common plot parameters ------------------------------------>
<!----------------------------------------------------------------------->

```{r setup-plot-parameters}

# order of factor levels
levels_species_allspec <- res_m_allspec$species |> unique() |> rev()
levels_species <- res_m$species |> unique() |> rev()
levels_vern_name_eng_allspec <- res_m_allspec$vern_name_eng |> unique() |> rev()
levels_vern_name_eng <- res_m$vern_name_eng |> unique() |> rev()
levels_vern_name_nld_allspec <- res_m_allspec$vern_name_nld |> unique() |> rev()
levels_vern_name_nld <- res_m$vern_name_nld |> unique() |> rev()
levels_stadium <- c(
  "irrelevant", "afwezig", "sporadisch aanwezig",
  "beperkt gevestigd", "wijdverspreid"
)
levels_milieu <- c(
  "freshwater",
  "freshwater, brackishwater",
  "freshwater, brackishwater, marine",
  "freshwater, terrestrial",
  "terrestrial",
  "terrestrial, brackishwater",
  "terrestrial, freshwater, brackishwater",
  "marine",
  "brackishwater, marine"
)
#
# colors stadium (cols4all - palette: met.lakota)
cols_stadium <- data.frame(
  cols = c("#247D3F", "#04A3BD", "#F0BE3D", "#DA7901", "#931E18"),
  stadium = levels_stadium
)
#
# colors feasibility urgency
cols_feasurge <- c("#04A3BD", "#DA7901")
#
# color to highlight data
col_hl <- "#F0BE3D"
#
# color for background data
col_bg <- "#E5E4E2"
#
# colors method categories (cols4all - 10 cols - palette: met.redon)
cols_meth <- c("#5B859E","#1E395F","#75884B","#1E5A46","#DF8D71","#AF4F2F","#D48F90","#732F30","#AB84A5","#59385C")
#
# color to highlight axis labels
col_labs <- "#71797E" #"#EA5F94"
#
# axis labels to highlight 
# these (only work if y axis not facetted)
labs_hl_allspec <- highlight_labs(
  labs = levels_vern_name_nld_allspec,
  pattern = "kreeft|muntjak",
  color = col_labs
)
labs_hl <- highlight_labs(
  labs = levels_vern_name_nld,
  pattern = "kreeft|muntjak",
  color = col_labs
)


```

<!----------------------------------------------------------------------->
<!---- begin plotting --------------------------------------------------->
<!----------------------------------------------------------------------->

## Species ranking

### Ranking according to grand mean response scores

Grand mean scores calculated across all scored questions irrespective of the survey section the question is in (e.g., "Introductie & vestiging", "Monitoring") or the question category ("feasibility" vs. "urgency").
Letters "F" and "U" mark the mean scores calculated per question category.
Note that the number of questions per survey section and consequently category varies across species in function of invasion stadium.
While this figure contains all species included in the survey, the following visualizations only concern the species of union concern.

```{r ranking, fig.width = fig_w * 1.2, fig.height = fig_h}

# convert to plot data
res_plot_tmp <- res_m_allspec |>
  dplyr::mutate(
    m_max = dplyr::case_when(
      m_feas > m_urge ~ m_feas,
      TRUE ~ m_urge
    ),
    m_min = dplyr::case_when(
      m_feas < m_urge ~ m_feas,
      TRUE ~ m_urge
    ),
    on_unionlist_upd = dplyr::case_when(
      on_unionlist ~ "on unionlist",
      !on_unionlist ~ "not on unionlist"
    ),
    part = dplyr::case_when(
      dplyr::row_number() < (dplyr::n()/2) ~ "part 1",
      TRUE ~ "part 2"
    )
  )
res_plot <- factorize(
  res = res_plot_tmp,
  varnames = c("species", "vern_name_eng", "vern_name_nld",
               "on_unionlist_upd", "stadium"),
  varlevels = list(
    levels_species_allspec,
    levels_vern_name_eng_allspec,
    levels_vern_name_nld_allspec,
    c("on unionlist", "not on unionlist"),
    levels_stadium
  )
)
#
# plot
# (split in 2 using facet_wrap - requires attention to labels)
plot_ranking <- ggplot2::ggplot(
  res_plot,
  ggplot2::aes(x = m_feasurge, y = vern_name_nld, color = stadium)) +
  ggplot2::geom_linerange(ggplot2::aes(xmin = 0, xmax = m_feasurge), linetype = "dotted") +
  ggplot2::geom_linerange(ggplot2::aes(xmin = m_min, xmax = m_max)) +
  ggplot2::geom_point(ggplot2::aes(x = m_feasurge), color = "white", size = 2) +
  ggplot2::geom_point(ggplot2::aes(x = m_feas), color = "white", size = 2) +
  ggplot2::geom_point(ggplot2::aes(x = m_feas), shape = "F") +
  ggplot2::geom_point(ggplot2::aes(x = m_urge), color = "white", size = 2) +
  ggplot2::geom_point(ggplot2::aes(x = m_urge), shape = "U") +
  ggplot2::geom_point(ggplot2::aes(shape = on_unionlist_upd), size = 2) +
  ggplot2::scale_shape_manual(values = c(16, 1)) +
  ggplot2::scale_color_manual(
    values = cols_stadium |>
      dplyr::filter(stadium %in% (res_plot$stadium |> unique())) |>
      dplyr::pull(cols)) +
  ggplot2::coord_cartesian(xlim = c(
    res_scored_allspec$response_score |> na.omit() |> min(),
    res_scored_allspec$response_score |> na.omit() |> max()
  )) +
  ggplot2::scale_y_discrete(labels = labs_hl_allspec) +
  ggplot2::theme_bw() +
  ggplot2::theme(
    legend.title = ggplot2::element_blank(),
    axis.text.y = ggtext::element_markdown(),
    panel.grid.major.y = ggplot2::element_blank(),
    panel.grid.minor.y = ggplot2::element_blank()
  ) +
  ggplot2::labs(
    x = "mean of feasibilty and urgency scores (grand mean)",
    y = "species (vernacular name nld)"
  )

plot_ranking
# closer to F if species is present as F then has more questions
# closer to U if species is absent as U then has more questions

```


## Invasion stadium

### Invasion stadium Prius vs. survey

Invasion stadium as reported in the PrIUS report against invasion stadium as reported in survey.
Species for which discrepancies occur are highlighted.

```{r invasion-stadium-1, fig.width = fig_w * 1.2, fig.height = fig_h * 0.75}

res_plot_tmp <- res_comb_upd |>
  dplyr::distinct(species, .keep_all = TRUE) |>
  dplyr::mutate(
    prius_stadium_upd = dplyr::case_when(
      grepl("IRR", prius_stadium) ~ "irrelevant",
      grepl("AFW", prius_stadium) ~ "afwezig",
      grepl("SPO", prius_stadium) ~ "sporadisch aanwezig",
      grepl("BEP", prius_stadium) ~ "beperkt gevestigd",
      grepl("VER", prius_stadium) ~ "wijdverspreid"
    ),
    on_unionlist_upd = dplyr::case_when(
      on_unionlist ~ "on unionlist",
      !on_unionlist ~ "not on unionlist"
    ),
    # stadium labels
    label_helper = paste(prius_stadium_upd, stadium, sep ="_")
  ) |>
  dplyr::group_by(label_helper) |>
  dplyr::mutate(
    stadium_label = dplyr::case_when(
      (prius_stadium_upd != stadium & dplyr::row_number() == 1) ~ paste(vern_name_nld, collapse = "\n"),
      TRUE ~ NA_character_
    )) |>
  dplyr::ungroup()
res_plot <- factorize(
  res_plot_tmp,
  c("stadium", "prius_stadium_upd", "on_unionlist_upd"),
  list(
    levels_stadium,
    levels_stadium,
    c("on unionlist", "not on unionlist")
  )
)
#
# plot
plot_stadium <- ggplot2::ggplot(
  res_plot,
  ggplot2::aes(x = prius_stadium_upd, y = stadium)) +
  ggplot2::geom_abline(intercept = 0, slope = 1, color = col_bg, linewidth = 2) +
  #ggplot2::geom_point(size = 12, shape = 21, fill = "white", color = col_bg) +
  ggplot2::geom_point(
    size = 3,
    position = ggplot2::position_jitter(width = 0.1, height = 0.1),
    alpha = .4
  ) +
  ggforce::geom_mark_circle(
    ggplot2::aes(
      label = stadium_label,
      filter = !is.na(stadium_label)),
    color = col_hl,
    label.fontface = "plain", label.fontsize = 10, label.colour = col_hl,
    con.type = "straight", con.colour = col_hl
  ) +
  ggplot2::facet_grid(
    cols = ggplot2::vars(on_unionlist_upd),
    scales = "free",
    space = "free"
  ) +
  ggplot2::scale_x_discrete(drop = FALSE) +
  ggplot2::scale_y_discrete(drop = FALSE) +
  ggplot2::theme_bw() +
  ggplot2::theme(
    axis.text.x = ggplot2::element_text(angle = 45, hjust = 1, vjust = 1),
    strip.background = ggplot2::element_blank()
  ) +
  ggplot2::labs(
    x = "stadium in prius",
    y = "stadium reported by expert"
  )

plot_stadium

```


### Invasion stadium and species distribution

Reported status of species distribution (to what extent known?) per species,
with species grouped by invasion stadium as reported in survey.

```{r invasion-stadium-2, fig.width = fig_w, fig.height = fig_h * 1.5}

res_plot_tmp1 <- res_scored |>
  dplyr::filter(grepl("B1", question_id)) |>
   # adapt response text
  dplyr::mutate(
    response_text_recoded = dplyr::case_when(
      grepl("ik weet het niet", response_text) ~ "weet niet",
      grepl("niet voldoende gekend", response_text) ~ "ongekend",
      grepl("geen goed beeld", response_text) ~ "gekend, maar kaart geeft geen goed beeld",
      grepl("geeft een goed beeld", response_text) ~ "gekend en kaart geeft goed beeld"
    ) 
  ) |>
  dplyr::arrange(response_score |> dplyr::desc())
res_plot_tmp2  <- factorize(
  res_plot_tmp1,
  c("stadium", "response_text_recoded"),
  list(
    levels_stadium,
    res_plot_tmp1$response_text_recoded |> unique() |> rev()
  )
) |> 
  dplyr::arrange(response_text_recoded)
res_plot <- res_plot_tmp2 |>
  factorize("vern_name_nld", list(res_plot_tmp2$vern_name_nld |> unique() |> rev()))
#
# plot
plot_stadium_dist <- ggplot2::ggplot(
  res_plot,
  ggplot2::aes(x = response_text_recoded, y = vern_name_nld)) +
  ggplot2::geom_point(size = 3) +
  ggplot2::facet_grid(
    rows = ggplot2::vars(stadium),
    scales = "free",
    space = "free",
    labeller = ggplot2::label_wrap_gen(width = 10)
  ) +
  ggplot2::scale_x_discrete(labels = ggplot2::label_wrap_gen(width = 20)) +
  ggplot2::theme_bw() +
  ggplot2::theme(
    axis.text.x = ggplot2::element_text(angle = 45, hjust = 1, vjust = 1),
    strip.background = ggplot2::element_blank(),
    strip.text.y.right = ggplot2::element_text(angle = 0)
  ) +
  ggplot2::labs(
    x = "distribution of species",
    y = "species (vernacular name nld)"
  )

plot_stadium_dist

```


## Response scores 

### Scoring of questions

How we currently assign scores to response options across all scored questions.
The question categories "feasibility" vs. "urgency" are distinguished by color.

```{r scoring-questions, fig.width = fig_w * 1.4, fig.height = fig_h * 1.5}

# get questions
q_file <- list.files(
  questions_path,
  pattern = "long.rda",
  full.names = TRUE
)
q_long <- get(load(q_file))
#
#
# prepare data for plotting
q_plot_tmp <- q_long |>
  # filter rows
  dplyr::filter(question_include_in_form == 1, question_use_for_ranking == 1) |>
  tidyr::drop_na(score_response_option) |>
  # insert line breaks & shorten responses
  dplyr::rowwise() |>
  dplyr::mutate(
    response_option = response_option |>
      stringr::str_trunc(string = _, width = 65) |>
      paste("-", y = _) |>
      stringr::str_wrap(width = 40) |>
      paste(x = _, NULL, collapse = "\n"),
  ) |>
  # merge responses based on response scores
  tidyr::pivot_wider(
    values_from = response_option,
    names_from = score_response_option,
    values_fn = function(x) paste(x, collapse = "\n")
  ) |>
  tidyr::pivot_longer(
    cols = paste(1:4),
    names_to = "score",
    values_to = "response"
  ) |>
  dplyr::mutate(
    score = as.numeric(score)
  ) |>
  # add question text short
  dplyr::left_join(
    x = _,
    y = res_scored |>
      dplyr::select(tidyselect::contains(c("question_id", "question_text_short"))) |>
      dplyr::distinct(question_id, .keep_all = TRUE)
  )
#
q_plot <- factorize(
  q_plot_tmp,
  c("question_text_short", "section_title"),
  list(
    q_plot_tmp$question_text_short |> unique() |> rev(),
    q_plot_tmp$section_title |> unique()
  )
)
#
# plot
plot_scoring <- ggplot2::ggplot(
  data = q_plot,
  mapping = ggplot2::aes(x = score, y = question_text_short)) +
  ggplot2::geom_label(
    ggplot2::aes(label = response, fill = score_category),
    hjust = 0,
    size = 3,
    angle = 0,
    alpha = .2
  ) +
  ggplot2::facet_grid(
    rows = ggplot2::vars(section_title),
    scales = "free",
    space = "free") +
  ggplot2::scale_x_continuous(
    breaks = 1:4,
    labels = paste(1:4, c("\nLow feasibility / urgency", "", "", "\nHigh feasibility / urgency"))
  ) +
  ggplot2::scale_fill_manual(values = cols_feasurge) + 
  ggplot2::labs(x = "", y = "") +
  ggplot2::coord_cartesian(xlim = c(0.8,4.8)) +
  ggplot2::theme_bw() +
  ggplot2::theme(
    panel.grid = ggplot2::element_blank(),
    strip.background = ggplot2::element_blank(),
    legend.title = ggplot2::element_blank(),
    legend.position = "bottom"
  )

plot_scoring

```


### Score distributions per question

Distribution of scores per question.
The question categories "feasibility" vs. "urgency" are distinguished by color.

```{r score-distributions, fig.width = fig_w * 1.2, fig.height = fig_h * 1.2}

# convert to plot data
res_plot_tmp <- res_scored |>
  dplyr::mutate(
    question_no = dplyr::row_number(),
    .by = c(species, section_no)
  )
#
# convert character vars to factors for ordering
res_plot <- factorize(
  res_plot_tmp,
  c("question_text", "question_text_short", "section_title"),
  list(
    res_plot_tmp$question_text |> unique(),
    res_plot_tmp$question_text_short |> unique(),
    res_plot_tmp$section_title |> unique() |> _[match(
      seq(min(res_plot_tmp$section_no), max(res_plot_tmp$section_no)),
      res_plot_tmp$section_no |> unique()
    )]
  )
)
#
# plot
plot_scoredist <- ggplot2::ggplot(res_plot, ggplot2::aes(response_score)) +
  ggplot2::geom_bar(ggplot2::aes(fill = score_crit)) +
  ggtext::geom_textbox(
    ggplot2::aes(x = 0.5, y = Inf, label = question_text_short),
    hjust = 0, vjust = -0.2, size = 2.5,
    box.padding = grid::unit(c(0, 0, 0, 0), "pt"),
    box.colour = "transparent", fill = "transparent",
    width = grid::unit(100, "pt")
  ) +
  ggh4x::facet_grid2(
    rows = ggplot2::vars(section_title),
    cols = ggplot2::vars(question_no),
    scales = "free",
    independent = "x",
    render_empty = FALSE,
    labeller = ggplot2::label_wrap_gen(width = 20)
  ) +
  ggplot2::scale_fill_manual(values = cols_feasurge) + 
  ggplot2::coord_cartesian(clip = "off") +
  ggplot2::theme_bw() +
  ggplot2::theme(
    strip.background = ggplot2::element_blank(),
    strip.text.x.top = ggplot2::element_blank(),
    strip.placement = "outside",
    panel.spacing.y = grid::unit(1.5, "lines"),
    legend.position = "bottom",
    legend.title = ggplot2::element_blank()
  ) +
  ggplot2::labs(
    x = "response score",
    y = "frequency"
  )

plot_scoredist

```


### Score proportions "unknown" vs. rest per species

Proportion of responses that fall into the category "ongekend / ik weet het niet"
across all questions per species.
Species are sorted according to grand mean response scores (highest on top).

```{r score-props-1, fig.width = fig_w * 1.2, fig.height = fig_h}

# convert to plot data
res_plot_tmp <- res_scored |>
  dplyr::mutate(
    score_category = dplyr::case_when(
      !grepl("ongekend|ik weet het niet", response_text) ~ "rest",
      TRUE ~ response_text |> gsub(" ", "", x = _)
    )
  ) |>
  # score category proportions per species
  dplyr::mutate(
    n_scores_category = dplyr::n(),
    .by = c(species, score_category)
  ) |>
  dplyr::mutate(
    n_scores_tot = dplyr::n(),
    .by = species
  ) |>
  dplyr::mutate(prop_scores = n_scores_category / n_scores_tot) |>
  tidyr::pivot_wider(
    data = _,
    names_from = score_category,
    values_from = prop_scores,
    names_prefix = "prop_scores_"
  ) |>
  dplyr::group_by(species) |>
  tidyr::fill(tidyselect::contains("prop_scores"), .direction = "downup") |>
  dplyr::ungroup() |>
  dplyr::mutate(dplyr::across(tidyselect::contains("prop_scores"), \(x) tidyr::replace_na(x, 0)))

# check whether proportions sum to 1
test <- res_plot_tmp |>
  dplyr::rowwise() |>
  dplyr::mutate(prop_check = rowSums(dplyr::across(tidyselect::starts_with("prop_scores"))))
assertthat::are_equal(sum(test$prop_check), nrow(test))
#
# convert character vars to factors for ordering
res_plot <- factorize(
  res_plot_tmp,
  c("question_text", "section_title", "species", "vern_name_nld"),
  list(
    res_plot_tmp$question_text |> unique(),
    res_plot_tmp$section_title |> unique() |> _[match(
      seq(min(res_plot_tmp$section_no), max(res_plot_tmp$section_no)),
      res_plot_tmp$section_no |> unique()
    )],
    levels_species,
    levels_vern_name_nld
  )
)
#
# plot
plot_unknown_prop_species <- ggplot2::ggplot(res_plot, ggplot2::aes(y = vern_name_nld)) +
  ggplot2::geom_linerange(
    ggplot2::aes(
      xmin = 0,
      xmax = prop_scores_ongekend + prop_scores_ikweethetniet,
      color = "ongekend / ik weet het niet"
    ),
    linewidth = 2
  ) +
  ggplot2::geom_linerange(
    ggplot2::aes(
      xmin = prop_scores_ongekend + prop_scores_ikweethetniet,
      xmax = prop_scores_ongekend + prop_scores_ikweethetniet + prop_scores_rest,
      color = "rest"
    ),
    linewidth = 2
  ) +
  ggplot2::scale_color_manual(values = c(col_hl, col_bg)) +
  ggplot2::coord_cartesian(xlim = c(0,1)) +
  ggplot2::theme_bw() +
  ggplot2::theme(
    axis.text.y = ggtext::element_markdown()
  ) +
  ggplot2::labs(
    x = "proportion responses",
    y = "species (vernacular name nld)",
    color = "category response"
  )

plot_unknown_prop_species

```


### Score proportions "unknown" vs. rest per question

Proportion of responses that fall into the category "ongekend / ik weet het niet"
across all species per question.

```{r score-props-2, fig.width = fig_w , fig.height = fig_h}

# convert to plot data
res_plot_tmp <- res_scored |>
  dplyr::mutate(
    score_category = dplyr::case_when(
      !grepl("ongekend|ik weet het niet", response_text) ~ "rest",
      TRUE ~ response_text |> gsub(" ", "", x = _)
    )
  ) |>
  # score category proportions per question
  dplyr::mutate(
    n_scores_category = dplyr::n(),
    .by = c(question_text, score_category)
  ) |>
  dplyr::mutate(
    n_scores_tot = dplyr::n(),
    .by = question_text
  ) |>
  dplyr::mutate(prop_scores = n_scores_category / n_scores_tot) |>
  tidyr::pivot_wider(
    data = _,
    names_from = score_category,
    values_from = prop_scores,
    names_prefix = "prop_scores_"
  ) |>
  dplyr::group_by(question_text) |>
  tidyr::fill(tidyselect::contains("prop_scores"), .direction = "downup") |>
  dplyr::ungroup() |>
  dplyr::mutate(dplyr::across(tidyselect::contains("prop_scores"), \(x) tidyr::replace_na(x, 0)))

# check whether proportions sum to 1
test <- res_plot_tmp |>
  dplyr::rowwise() |>
  dplyr::mutate(prop_check = rowSums(dplyr::across(tidyselect::starts_with("prop_scores"))))
assertthat::are_equal(sum(test$prop_check), nrow(test))
#
# convert character vars to factors for ordering
res_plot <- factorize(
  res_plot_tmp,
  c("question_text_short", "section_title", "species", "vern_name_nld"),
  list(
    res_plot_tmp$question_text_short |> unique(),
    res_plot_tmp$section_title |> unique() |> _[match(
      seq(min(res_plot_tmp$section_no), max(res_plot_tmp$section_no)),
      res_plot_tmp$section_no |> unique()
    )],
    levels_species,
    levels_vern_name_nld
  )
)
#
# plot
plot_unknown_prop_question <- ggplot2::ggplot(res_plot, ggplot2::aes(x = question_text_short)) +
  ggplot2::geom_linerange(
    ggplot2::aes(
      ymin = 0,
      ymax = prop_scores_ongekend + prop_scores_ikweethetniet,
      color = "ongekend / ik weet het niet"
    ),
    linewidth = 2
  ) +
  ggplot2::geom_linerange(
    ggplot2::aes(
      ymin = prop_scores_ongekend + prop_scores_ikweethetniet,
      ymax = prop_scores_ongekend + prop_scores_ikweethetniet + prop_scores_rest,
      color = "rest"
    ),
    linewidth = 2
  ) +
    ggplot2::facet_grid(
    cols = ggplot2::vars(section_title),
    scales = "free",
    space = "free"
  ) +
  ggplot2::scale_color_manual(values = c(col_hl, col_bg)) +
  #ggplot2::scale_y_discrete(labels = labs_hl) +
  ggplot2::coord_cartesian(ylim = c(0,1)) +
  ggplot2::theme_bw() +
  ggplot2::theme(
    axis.text.x = ggplot2::element_text(angle = 45, hjust = 1, vjust = 1),
    strip.background = ggplot2::element_blank()
  ) + 
  ggplot2::labs(
    x = "question",
    y = "proportion responses",
    color = "category response"
  )

plot_unknown_prop_question

```

### Score patterns "unknown" vs. rest per species and question

Responses that fall into the category "ongekend / ik weet het niet"
per question and per species.
Species are sorted according to grand mean response scores (highest on top).

```{r score-patterns, fig.width = fig_w * 1.2, fig.height = fig_h}

res_plot_upd <- res_plot |>
  dplyr::mutate(
    score_category = dplyr::case_when(
      !grepl("ongekend|ik weet het niet", response_text) ~ "rest",
      TRUE ~ "ongekend / ik weet het niet"
    )
  )

plot_unknown_pattern <- ggplot2::ggplot(
  res_plot_upd,
  ggplot2::aes(
    x = question_text_short, y = vern_name_nld,
    fill = score_category, color = score_category
  )
) +
  ggplot2::geom_point(size = 3, shape = 21) +
  ggplot2::facet_grid(
    cols = ggplot2::vars(section_title),
    scales = "free",
    space = "free"
  ) +
  ggplot2::scale_color_manual(values = c(col_hl, col_bg)) +
  ggplot2::scale_fill_manual(values = c(col_hl, col_bg)) +
  ggplot2::scale_y_discrete(labels = labs_hl) +
  ggplot2::theme_bw() +
  ggplot2::theme(
    axis.text.x = ggplot2::element_text(angle = 45, hjust = 1, vjust = 1),
    strip.background = ggplot2::element_blank(),
    axis.text.y = ggtext::element_markdown()
  ) +
  ggplot2::labs(
    x = "question",
    y = "species (vernacular name nld)",
    color = "category response",
    fill = "category response"
  )

plot_unknown_pattern

```


## Methods

```{r methods-prep}

# get recoded and processed data
res_meth_recoded <- get(load(paste0(response_data_path, "recoded_processed/", "results_methods_recoded.rda"))) 
res_meth_options <- get(load((paste0(response_data_path, "recoded_processed/", "results_methods_options.rda"))))
#
#
#


```

### Frequency of methods

Methods reported in survey by frequency.
Note that per species multiple methods could be reported. 
Methods are grouped into categories distinguished by color.


```{r methods-freq, fig.width = fig_w, fig.height = fig_h}
# frequency plot also for best methods
#
# get response options per species in long format
res_plot_tmp1 <- res_meth_recoded |>
  dplyr::filter(grepl("D1$", question_id), !grepl("followup", question_text)) |>
  tidyr::crossing(res_meth_options) |>
  dplyr::relocate(tidyselect::any_of(tidyselect::starts_with("response_options")),
                  .after = response_text_final) |>
  dplyr::group_by(species) |>
  dplyr::rowwise() |>
  dplyr::filter(grepl(pattern = response_options, x = response_text_final)) |>
  dplyr::ungroup()
#
#
# count response option across species
res_plot_tmp2 <- res_plot_tmp1 |>
  dplyr::mutate(
    response_count = dplyr::n(),
    .by = response_options,
    .after = response_options
  ) |>
  dplyr::distinct(
    response_options,
    .keep_all = TRUE
  ) |>
  dplyr::arrange(response_count)
#
res_plot <- factorize(
  res = res_plot_tmp2,
  varnames = c("response_options", "response_options_cat"),
  varlevels = list(res_plot_tmp2$response_options,
                   res_meth_options$response_options_cat |> unique()
                   )
)
#
# plot
plot_meth_freq <- ggplot2::ggplot(res_plot) +
  ggplot2::geom_linerange(
    ggplot2::aes(xmin = 0, xmax = response_count,
                 y = response_options,
                 color = response_options_cat),
    linewidth = 2
  ) +
  ggplot2::scale_color_manual(values = c(cols_meth)) +
  ggplot2::theme_bw() +
  ggplot2::theme(
    panel.grid.minor.y = ggplot2::element_blank(),
    panel.grid.major.y = ggplot2::element_blank()
  ) +
  ggplot2::labs(
    x = "frequency",
    y = "method",
    color = "method category"
  )

plot_meth_freq

```

### Methods combinations

Frequencies of all reported pairwise methods combinations. 
Methods are sorted by frequency.

```{r methods-network, fig.width = fig_w * 1.2, fig.height = fig_h * 1.2}

### plot combination of method within species (network graph)
#
# get maximum number of methods selected
methods_n_max <- res_plot_tmp1 |>
  dplyr::count(species) |>
  dplyr::pull(n) |>
  max()
#
# get number of unique pairwise methods combinations (ignoring order)
methods_pw_max <- methods_n_max * (methods_n_max - 1) / 2
#
# prepare plot data 
res_plot_tmp <- res_plot_tmp1 |>
  dplyr::mutate(
    tmp = dplyr::row_number(),
    .by = species
  ) |>
  dplyr::select(-response_options_cat) |>
  tidyr::pivot_wider(
    names_from = tmp,
    names_prefix = "method_",
    values_from = response_options
  ) |>
  # get all unique pairwise combinations of method columns
  dplyr::rowwise() |>
  dplyr::mutate(
    method_pw = combn(
      x = dplyr::across(tidyselect::contains("method")), # & where !is.na not working
      m = 2,
      FUN = paste,
      collapse = ";"
    ) |> paste(x = _, collapse = ",")
  ) |>
  # separate pairwise combinations into columns
  tidyr::separate_wider_delim(
    cols = method_pw,
    delim = ",",
    names = paste0("method_pw_", 1:methods_pw_max),
    too_few = "align_start"
  ) |>
  # transform to long format
  tidyr::pivot_longer(
    cols = tidyselect::starts_with("method_pw"),
    names_to = "method_pw_name",
    values_to = "method_pw_value"
  ) |>
  # remove combinations containing NA
  dplyr::filter(
    !grepl("NA\\;|\\;NA", method_pw_value)
  ) |>
  # separate methods pw values into from and to columns
  tidyr::separate_wider_delim(
    cols = method_pw_value,
    delim = ";",
    names = c("from", "to")
  ) |>
  # turn into network data
  dplyr::select(c("from", "to")) |>
  tidygraph::as_tbl_graph(x = _, directed = FALSE) |>
  tidygraph::activate(edges) |>
  dplyr::group_by(from, to) |>
  dplyr::mutate(n_links = dplyr::n()) |>
  dplyr::ungroup() |>
  tidygraph::activate(nodes) |>
  dplyr::arrange(match(name, res_plot_tmp2$response_options))
#
plot_meth_netw <- ggraph::ggraph(graph = res_plot_tmp, layout = 'linear', circular = FALSE) +
  ggraph::geom_edge_arc(ggplot2::aes(edge_width = n_links/1.5, label = n_links, alpha = (n_links + 10)/100),
                        #label_dodge = grid::unit(3, 'mm'),
                        angle_calc = 'along',
                        label_size = 4,
                        colour = col_hl,
                        lineend = "butt"
  ) +
  ggraph::geom_node_text(ggplot2::aes(label = name), nudge_y = -0.1, hjust = 1) +
  ggplot2::coord_flip(ylim = c(-2,9)) +
  ggplot2::theme_void()

plot_meth_netw

```

### Methods across species

Methods reported per species. 
Methods are grouped by method category, species by kingdom. 
The methods reported as "most relevant" are highlighted.
Within groups species are sorted according to grand mean response scores (highest on top).


```{r methods-pattern-1, fig.width = fig_w * 1.2, fig.height = fig_h * 1.2}
#
# convert to plot data
res_plot <- factorize(
  res = res_plot_tmp1,
  varnames = c("vern_name_nld", "response_options", "response_options_cat", "prius_milieu"),
  varlevels = list(levels_vern_name_nld,
                   res_meth_options$response_options,
                   res_meth_options$response_options_cat |> unique(),
                   levels_milieu
                   )
)
#
# create helper data - here to collect methods with lines per species
response_options_used <- dplyr::right_join(
  res_meth_options,
  res_plot_tmp1 |>
    dplyr::distinct(response_options)
)
#
data_helper_tmp <- response_options_used |>
  dplyr::mutate(
    rownumber = dplyr::row_number()
  ) |>
  dplyr::mutate(
    x_cat = dplyr::row_number() ,
    .by = response_options_cat
  ) |>
  tidyr::crossing(data.frame(
    species = res_plot_tmp1$species,
    vern_name_nld = res_plot_tmp1$vern_name_nld)
    )|>
  dplyr::left_join(
    x = _,
    y = res_plot_tmp1
  ) |>
   dplyr::group_by(species) |>
  tidyr::fill(prius_milieu, kingdom, .direction = "downup")|>
     dplyr::ungroup(species) |>
  dplyr::arrange(species, rownumber)  
#
data_lines <- data_helper_tmp |>
  # remove leading and trailing NAs
  dplyr::group_by(species) |>
  dplyr::filter(cumsum(!is.na(stadium)) != 0 & rev(cumsum(!is.na(rev(stadium)))) != 0) |>
  dplyr::ungroup() |>
  # add x_min and x_max per category
  dplyr::group_by(species, response_options_cat) |>
  dplyr::mutate(
    x_cat_min = x_cat |> min(),
    x_cat_max = x_cat |> max(),
    .after = x_cat
  ) |>
  dplyr::slice_head() |>
  dplyr::ungroup() |>
  # adjust in between values
  dplyr::arrange(species, rownumber)|>
  dplyr::mutate(
    x_cat_min = dplyr::case_when(
      dplyr::row_number() == 1 ~ x_cat_min,
      TRUE ~ x_cat_min - 0.5
      ),
    x_cat_max = dplyr::case_when(
      dplyr::row_number() == dplyr::n()  ~ x_cat_max,
      TRUE ~ x_cat_max + 0.5
    ),
    .by = species
    ) |>
  dplyr::ungroup() |>
  factorize(
    res = _,
    varnames = c("vern_name_nld", "response_options", "response_options_cat", "prius_milieu"),
    varlevels = list(levels_vern_name_nld,
                     res_meth_options$response_options,
                     res_meth_options$response_options_cat |> unique(),
                     levels_milieu
                     )
  )
#
# data best methods (reply "geen" turns NA)
res_plot_best <- res_meth_recoded |>
  dplyr::filter(grepl("D2$", question_id)) |>
  tidyr::crossing(res_meth_options) |>
  dplyr::relocate(tidyselect::any_of(tidyselect::starts_with("response_options")),
                  .after = response_text_final) |>
  dplyr::group_by(species) |>
  dplyr::rowwise() |>
  dplyr::filter(grepl(pattern = response_options, x = response_text_final)) |>
  dplyr::ungroup() |>
  factorize(
    res = _,
    varnames = c("vern_name_nld", "response_options", "response_options_cat", "prius_milieu"),
    varlevels = list(levels_vern_name_nld,
                     res_meth_options$response_options,
                     res_meth_options$response_options_cat |> unique(),
                     levels_milieu
    )
  )
#
# plot
plot_meth_patt <- ggplot2::ggplot(
  res_plot,
  ggplot2::aes(
    x = response_options, y = vern_name_nld, group = response_options_cat
    )
) +
  ggplot2::facet_grid(
    cols = ggplot2::vars(response_options_cat),
    rows = ggplot2::vars(kingdom),
    scales = "free",
    space = "free"
  ) +
  ggplot2::geom_point(size = 3, shape = 21) +
  ggplot2::geom_linerange(data = data_lines, ggplot2::aes(xmin = x_cat_min, xmax = x_cat_max), linetype = "dashed") +
  ggplot2::geom_point(data = res_plot_best, size = 3) +
  #ggplot2::scale_y_discrete(labels = labs_hl) +
  ggplot2::theme_bw() +
  ggplot2::theme(
    strip.background = ggplot2::element_blank(),
    strip.text.x.top = ggplot2::element_text(angle = 20, hjust = 0, vjust = 0),
    axis.text.x = ggplot2::element_text(angle = 45, hjust = 1, vjust = 1),
    axis.text.y = ggtext::element_markdown()
  ) +
  ggplot2::labs(
    x = "methods",
    y = "species (vernacular name nld)",
    color = "category response",
    fill = "category response"
  )

plot_meth_patt


```


### Methods across species by habitat

Methods reported per species.
Methods are grouped by method category, species by habitat as reported in PrIUS. 
The methods reported as "most relevant" are highlighted.
Within groups species are sorted according to grand mean response scores (highest on top).
Grid cells with at least 1 species-habitat combination are colored.

```{r methods-pattern-2, fig.width = fig_w * 1.2, fig.height = fig_h * 1.2}

# define data background filling (no fill if no entry in group)
data_bg <- data_helper_tmp |>
  dplyr::group_by(species, prius_milieu, response_options_cat) |>
    dplyr::mutate(
    x_cat_min = 0.5,
    x_cat_max = dplyr::n() + 0.5
  )|>
  dplyr::ungroup() |>
  dplyr::group_by(prius_milieu, response_options_cat, response_options) |>
  dplyr::mutate(
    y_cat_min = 0.5,
    y_cat_max = dplyr::n() + 0.5
  ) |>
  dplyr::ungroup() |>
  # add alpha
  dplyr::group_by(response_options_cat, prius_milieu) |>
    dplyr::mutate(
    alpha = dplyr::case_when(
      any(!is.na(stadium)) ~ 1,
      TRUE ~ 0
      )
  ) |> 
  dplyr::ungroup() |>
  dplyr::distinct(response_options_cat, prius_milieu, .keep_all = TRUE) |>
  # finalize
  factorize(
    res = _,
    varnames = c("vern_name_nld", "response_options", "response_options_cat", "prius_milieu"),
    varlevels = list(levels_vern_name_nld,
                     res_meth_options$response_options,
                     res_meth_options$response_options_cat |> unique(),
                     levels_milieu
                     )
  )
#
plot_meth_group <- plot_meth_patt + 
  ggplot2::geom_rect(
    data = data_bg,
    ggplot2::aes(
      xmin = x_cat_min, xmax = x_cat_max, 
      ymin = y_cat_min, ymax = y_cat_max,
      alpha = alpha |> as.numeric()
      ),
    fill = col_hl
  ) +
  ggplot2::facet_grid(
    cols = ggplot2::vars(response_options_cat),
    rows = ggplot2::vars(prius_milieu),
    scales = "free",
    space = "free",
    labeller = ggplot2::label_wrap_gen(width = 20)
  ) +
  ggplot2::scale_alpha(range = c(0, 0.2)) +  
  ggplot2::scale_y_discrete(labels = ggplot2::waiver()) + 
  ggplot2::theme(
    strip.text.x.top = ggplot2::element_text(angle = 20),
    strip.text.y.right = ggplot2::element_text(angle = 0),
    legend.position = "none",
    panel.spacing.y = grid::unit(1, "lines"),
    strip.clip = "off"
  )
plot_meth_group


```


### Characteristics best method

Frequencies of responses options per "most relevant" method.
Responses concerning sensitivity, specificity and costs are separated by column.


```{r best-method, fig.width = fig_w * 1.2, fig.height = fig_h * 1.2}

res_plot_tmp <- res_plot_best |> 
  dplyr::distinct(species, .keep_all = TRUE) |>
  dplyr::rename(best_method = response_text_final) |>
  dplyr::select(tidyselect::contains(c("species", "best_method"))) |>
  dplyr::full_join(
    x = _,
    y = res_scored |> 
      dplyr::filter(grepl("D3|D4|D5", question_id)) |>
      dplyr::filter(!grepl("followup", question_text))
  ) |>
  # adapt response text
  dplyr::mutate(
    response_text_recoded = dplyr::case_when(
      grepl("ongekend|ik weet het niet", response_text) ~ "ongekend / weet niet",
      grepl("lage", response_text) ~ "laag",
      grepl("middelhoge", response_text) ~ "middelhoog",
      grepl("^hoge", response_text) ~ "hoog"
    ) 
  ) |>
  # sort according to response score and frequency best method
  dplyr::mutate(
    n_rows = dplyr::n(), 
    .by = best_method
  ) |>
  dplyr::arrange(
    n_rows |> dplyr::desc(),
    response_score
    )
#
res_plot <- res_plot_tmp |>
  factorize(
    res = _,
    varnames = c("best_method", "question_text_short", "response_text_recoded"),
    varlevels = list(res_plot_tmp$best_method |> unique(),
                     res_plot_tmp$question_text_short |> unique() |> rev(),
                     res_plot_tmp$response_text_recoded |> unique()
    )
  )
#
plot_bestmeth <- ggplot2::ggplot(
  res_plot, 
  ggplot2::aes(x = response_text_recoded)
  ) +
  ggplot2::geom_bar() +
  ggplot2::facet_grid(
    rows = ggplot2::vars(best_method),
    cols = ggplot2::vars(question_text_short),
    labeller = ggplot2::label_wrap_gen(width = 20),
    switch = "y",
    scales = "free"
  ) +
  ggplot2::scale_y_continuous(breaks = \(x) seq(floor(min(x)), ceiling(max(x)), by = ceiling(max(x)/4))) +
  ggplot2::coord_cartesian(clip = "off") +
  ggplot2::theme_bw() +
  ggplot2::theme(
    strip.background = ggplot2::element_blank(),
    strip.text.y.left = ggplot2::element_text(angle = 0),
    strip.placement = "outside",
    axis.text.x = ggplot2::element_text(angle = 45, hjust = 1, vjust = 1)
  ) +
  ggplot2::labs(
    x = "response score",
    y = "frequency"
  )
plot_bestmeth
# NA value?

```



## Monitoring schemes

```{r moni-prep}
#
#
# get recoded and processed data 
res_moni_recoded <- get(load(paste0(response_data_path, "recoded_processed/", "results_monitoring_recoded.rda"))) 
res_moni_options <- get(load((paste0(response_data_path, "recoded_processed/", "results_monitoring_options.rda"))))

```

### Monitoring schemes across species

Monitoring schemes reported per species. 
Monitoring schemes are sorted by the number of species they cover (highest coverage left).
Species are grouped by kingdom, and within groups sorted according to grand mean response scores (highest on top).


```{r moni-pattern, fig.width = fig_w * 1.2, fig.height = fig_h * 1.2}
#
#
# get response options per species in long format
res_plot_tmp <- res_moni_recoded |>
  dplyr::filter(grepl("D8", question_id)) |>
  tidyr::crossing(res_moni_options) |>
  dplyr::relocate(tidyselect::any_of(tidyselect::starts_with("response_options")),
                  .after = response_text_final) |>
  dplyr::group_by(species) |>
  dplyr::rowwise() |>
  dplyr::filter(grepl(pattern = response_options, x = response_text_final)) |>
  dplyr::ungroup() |>
  # sort schemes according to number of species covered
  dplyr::mutate(
    n_species = dplyr::n(),
    .by = response_options
  ) |> 
  dplyr::arrange(n_species |> dplyr::desc()) |>
  # separate informative answers from uninformative ones
  dplyr::mutate(
    response_category =   dplyr::case_when(
      grepl("geen|weet het niet|^andere$", response_options) ~ "monitoring scheme absent or unknown",
      TRUE ~ "monitoring scheme reported"
    )
  )
#
# convert to plot data
res_plot <- factorize(
  res = res_plot_tmp,
  varnames = c("vern_name_nld", "response_options", "prius_milieu"),
  varlevels = list(levels_vern_name_nld,
                   res_plot_tmp$response_options |> unique(),
                   levels_milieu
                   )
)
#
# plot
plot_moni_patt <- ggplot2::ggplot(
  res_plot,
  ggplot2::aes(x = response_options, y = vern_name_nld)
) +
  ggplot2::facet_grid(
    rows = ggplot2::vars(kingdom), 
    cols = ggplot2::vars(response_category), 
    scales = "free",
    space = "free",
    labeller = ggplot2::label_wrap_gen(width = 15)
  ) +
  ggplot2::geom_point(size = 3) +
  ggplot2::scale_x_discrete(labels = ggplot2::label_wrap_gen(width = 30)) +
  ggplot2::theme_bw() +
  ggplot2::theme(
    strip.background = ggplot2::element_blank(),
    strip.text.x.top = ggplot2::element_text(angle = 0, hjust = 0, vjust = 0),
    axis.text.x = ggplot2::element_text(angle = 45, hjust = 1, vjust = 1),
    axis.text.y = ggtext::element_markdown(),
    strip.text.y.right = ggplot2::element_text(angle = 0)
  ) +
  ggplot2::labs(
    x = "methods",
    y = "species (vernacular name nld)"
  )
plot_moni_patt
# add lines to mark species - scheme combinations
# manually add systems not mentioned in survey but listed in ias eu reporting table 

```
