---
title: "Plan of action"
author: "Janne Adolf, Diederik Strubbe, Tim Adriaens, Thierry Onkelinx"
format: 
  html:
    toc: true
    toc-location: left
    toc-depth: 4
    toc-expand: true
    theme: yeti
    number-sections: true
    number-depth: 3
execute: 
  eval: true
  echo: false
  cache: false
---


```{r load-data-and-functions}
#| cache: false

list.files("../../../functions", full.names = TRUE) |>
  lapply(source) |>
  invisible()

options(knitr.kable.NA = '')
options(knitr.table.format = "html") 

response_data_path <- "../../../../data/survey_experts/" 
load(paste0(response_data_path, "tables/", "table_base_filtered.rda"))
load(paste0(response_data_path, "tables/", "table_base_illustration.rda"))
load(paste0(response_data_path, "tables/", "table_filtered_illustration.rda"))

```

```{r define-colors}

color_hl = "#FA8775"
color_meth_a = "#0000FF"
color_meth_b = "#FFB14E" # "#CD34B5"

```

```{r define-function-add-symbols}

add_symbols <- function(
    .table_base_filtered,
    .symbols_base_list = symbols_base_list,
    .symbols_filtered_list = symbols_filtered_list
){
  .table_base_filtered |>
    #
    # add symbols for scope boolean motivation
    dplyr::mutate(
      scope_boolean_symbol = NA_character_,
      .after = scope_boolean_motivation
    ) |>
    dplyr::rowwise() |>
    dplyr::mutate(
      scope_boolean_symbol = dplyr::case_when(
        grepl("invasion stadium", scope_boolean_motivation) ~
          paste(scope_boolean_symbol, .symbols_base_list$stadium, sep = ", "),
        TRUE ~ scope_boolean_symbol
      ),
      scope_boolean_symbol = dplyr::case_when(
        grepl("area is known", scope_boolean_motivation) ~
          paste(scope_boolean_symbol, .symbols_base_list$area, sep = ", "),
        TRUE ~ scope_boolean_symbol
      ),
      scope_boolean_symbol = dplyr::case_when(
        grepl("not managed", scope_boolean_motivation) ~
          paste(scope_boolean_symbol, .symbols_base_list$management_exists, sep = ", "),
        TRUE ~ scope_boolean_symbol
      ),
      scope_boolean_symbol = dplyr::case_when(
        grepl("evaluate management", scope_boolean_motivation) ~
          paste(scope_boolean_symbol, .symbols_base_list$management_eval, sep = ", "),
        TRUE ~ scope_boolean_symbol
      ),
      scope_boolean_symbol = dplyr::case_when(
        grepl("measure abundance", scope_boolean_motivation) ~
          paste(scope_boolean_symbol, .symbols_base_list$method, sep = ", "),
        TRUE ~ scope_boolean_symbol
      )
    )|>
    #
    # add sumbols for scope prior motivation
    dplyr::mutate(
      scope_prior_symbol = NA_character_,
      .after = scope_prior_motivation
    ) |>
    dplyr::rowwise() |>
    dplyr::mutate(
      scope_prior_symbol = dplyr::case_when(
        grepl("opportunistic observations", scope_prior_motivation) ~
          paste(scope_prior_symbol, .symbols_filtered_list$observation, sep = ", "),
        TRUE ~ scope_prior_symbol
      ),
      scope_prior_symbol = dplyr::case_when(
        grepl("area is not known", scope_prior_motivation) ~
          paste(scope_prior_symbol, .symbols_filtered_list$area, sep = ", "),
        TRUE ~ scope_prior_symbol
      ),
      scope_prior_symbol = dplyr::case_when(
        grepl("global priority score", scope_prior_motivation) ~
          paste(scope_prior_symbol, .symbols_filtered_list$globalscore, sep = ", "),
        TRUE ~ scope_prior_symbol
      )
    )|>
    #
    # final formatting symbols
    dplyr::mutate(
      scope_boolean_symbol = gsub("NA, ", "", scope_boolean_symbol),
      scope_prior_symbol = gsub("NA, ", "", scope_prior_symbol)#,
    ) |>
    dplyr::ungroup()
}

```

```{r add-symbols}

symbols_base_list <- list(
  stadium = "$\\circ$", 
  area = "$\\#$", 
  management_exists = "$\\dagger$", 
  management_eval = "$\\ddagger$",
  method = "$\\bot$"
)
symbols_filtered_list <- list(
  observation = "$\\triangle$",
  area = "$\\times$",
  globalscore = "$\\ast$"
)
table_base_filtered_upd <- add_symbols(table_base_filtered)
table_base_illu_list_upd <- lapply(table_base_illu_list, add_symbols)
table_filtered_illu_list_upd <- lapply(table_filtered_illu_list, add_symbols)

```

```{r add-scope-verbose}

# full table base
table_base_upd <- table_base_filtered_upd |>
  dplyr::mutate(
    scope_verbose = dplyr::case_when(
      scope_boolean == 1 ~ method_all,
      scope_boolean == 0 ~ scope_boolean_symbol
    ),
    .after = scope_boolean
  )
#
# illustration table base
table_base_illu_list_upd <- lapply(
  table_base_illu_list_upd,
  \(x)
  dplyr::mutate(.data = x,
                scope_verbose = dplyr::case_when(
                  scope_boolean == 1 ~ "",
                  scope_boolean == 0 ~ scope_boolean_symbol
                ),
                .after = scope_boolean
  )
)
#
# full table filtered
table_filtered_upd <- table_base_filtered_upd |>
  dplyr::mutate(
    scope_verbose = dplyr::case_when(
      scope_boolean == 1 & grepl("highprior", scope_prior) ~ 
        kableExtra::cell_spec(x = method_all, bold = TRUE),
      scope_boolean == 1 & grepl("lowprior", scope_prior) ~ 
        paste(scope_prior_symbol, kableExtra::cell_spec(x = method_all, color = "lightgrey")),
      scope_boolean == 0 ~ 
        kableExtra::cell_spec(x = scope_boolean_symbol, color = "lightgrey")
    ),
    .after = scope_prior
  ) |>
  dplyr::select(!tidyselect::starts_with("scope_boolean"))
#
# illustration table filtered
table_filtered_illu_list_upd <- lapply(
  table_filtered_illu_list_upd,
  \(x) dplyr::mutate(
    .data = x,
    scope_verbose = dplyr::case_when(
      scope_boolean == 1 & grepl("highprior", scope_prior) ~ 
        kableExtra::cell_spec(x = method_all, bold = TRUE),
      scope_boolean == 1 & grepl("lowprior", scope_prior) ~ 
        # setup so that later highlighting does not break
        paste0(kableExtra::cell_spec(x = method_all, color = "lightgrey"), ", ", scope_prior_symbol ),
        #scope_prior_symbol,
      scope_boolean == 0 ~ 
        kableExtra::cell_spec(x = scope_boolean_symbol, color = "lightgrey")
    ),
    .after = scope_prior
  )
)

```

```{r highlight-symbols-illustration}

tmp_fun <- function(table, symbol){
  dplyr::mutate(
    .data = table,
    scope_verbose = dplyr::case_when(
      grepl(symbol, scope_verbose) ~ paste0(
        # remove text after last comma
        sub("([^,]*)$"," ", scope_verbose),
        kableExtra::cell_spec(
          # remove text before and including last comma
          x = sub('.*\\,', "", scope_verbose),
          color = color_hl,
          bold = TRUE
        )
      ),
      TRUE ~ scope_verbose
    )
  )
  
}
table_base_illu_list_upd <- mapply(
  tmp_fun,
  table_base_illu_list_upd,
  # prep for grepl
  symbols_base_list |>
    lapply(X = _, FUN = \(x) 
           gsub(pattern = "\\$", replacement = "", x = x) |>
             gsub(pattern = "\\\\d", replacement = "\\\\\\\\d", x = _) |>
             gsub(pattern = "\\\\b", replacement = "\\\\\\\\b", x = _)
           ),
  SIMPLIFY = FALSE
)
table_filtered_illu_list_upd <- mapply(
  tmp_fun,
  table_filtered_illu_list_upd,
  # prep for grepl
  symbols_filtered_list |>
    lapply(X = _, FUN = \(x) 
           gsub(pattern = "\\$", replacement = "", x = x) |>
             gsub(pattern = "\\\\t", replacement = "\\\\\\\\t", x = _) |>
             gsub(pattern = "\\\\a", replacement = "\\\\\\\\a", x = _)
           ),
  SIMPLIFY = FALSE
)


```

```{r define-table-footnotes}

footnote_base <- table_base_upd |>
  dplyr::filter(!grepl(",", scope_boolean_motivation)) |>
  dplyr::select(c(scope_verbose, scope_motivation = scope_boolean_motivation)) |>
  tidyr::drop_na() |>
  dplyr::distinct(scope_motivation, .keep_all = TRUE) |>
  dplyr::arrange(
    match(
      scope_verbose,
      symbols_base_list |> unlist() |> unname() 
    )
  )
footnote_filtered <- table_filtered_upd |> 
  dplyr::filter(!grepl(",", scope_prior_motivation)) |>
  dplyr::select(c(scope_verbose = scope_prior_symbol, scope_motivation = scope_prior_motivation)) |>
  tidyr::drop_na() |>
  dplyr::distinct(scope_motivation, .keep_all = TRUE) |>
  dplyr::arrange(
    match(
      scope_verbose,
      symbols_filtered_list |> unlist() |> unname() 
    )
  )
footnote_combined <- dplyr::bind_rows(footnote_base, footnote_filtered)
```

```{r factorize-data-for-display}

args_factorize <- list(
  varnames = c("scope_type", "stadium", "prius_milieu"),
  varlevels = list(c("detection",
                     "inventory",
                     "distribution",
                     "abundance",
                     "distribution_management",
                     "abundance_management"),
                   c("afwezig",
                     "sporadisch aanwezig",
                     "beperkt gevestigd",
                     "wijdverspreid"),
                   c(
                     "freshwater",
                     "freshwater, brackishwater",
                     "freshwater, brackishwater, marine",
                     "freshwater, terrestrial",
                     "terrestrial",
                     "terrestrial, brackishwater",
                     "terrestrial, freshwater, brackishwater",
                     "marine",
                     "marine, brackisch, freshwater",
                     "brackishwater, marine"
                   )
  )
)
#
table_base_upd <- do.call("factorize", append(args_factorize, list(dataframe =   table_base_upd)))
table_filtered_upd <- do.call("factorize", append(args_factorize, list(dataframe =   table_filtered_upd)))
#
table_base_illu_list_upd <- lapply(
  table_base_illu_list_upd,
  \(x) do.call("factorize", append(args_factorize, list(dataframe = x)))
)
table_filtered_illu_list_upd <- lapply(
  table_filtered_illu_list_upd,
  \(x) do.call("factorize", append(args_factorize, list(dataframe = x)))
)

```

```{r define-function-make-table-display}

make_table_display <- function(
    data_table,
    cols_id = c(
      "species",
      "vern_name_nld",
      "stadium"
    ),
    cols_addon = c(
      "m_score"
    ),
    footnote_data = footnote_base
){
  data_table_wide <- data_table |>
    tidyr::pivot_wider(
      id_cols = !tidyselect::starts_with("scope_"),
      names_from = scope_type,
      values_from = scope_verbose,
      names_prefix = "scope_"
    ) |>
    dplyr::select(
      tidyselect::all_of(cols_id) |
        tidyselect::all_of(c(
          "scope_detection",
          "scope_inventory",
          "scope_distribution",
          "scope_abundance",
          "scope_distribution_management",
          "scope_abundance_management"
        )) |
        tidyselect::all_of(cols_addon)
    )
  #
  knitr::kable(
    x = data_table_wide,
    format = "html",
    escape = FALSE,
    col.names = colnames(data_table_wide) |>
      gsub(pattern = "scope_", replacement = "", x = _) |>
      gsub(pattern = "_", replacement = " ", x = _) |>
      stringr::str_wrap(width = nchar("abundance")), #|> 
      #gsub(pattern = "\\n", replacement = "\\\\n", x = _),
    table.attr = 'data-quarto-disable-processing="true"' # if quarto HERE
  ) |>
    # background of id and addon cols
    kableExtra::column_spec(
      column = 
        c(seq_along(cols_id), seq_along(cols_addon) + length(cols_id) + 6),
      background = "grey97"
    ) |>
    # borders of scope cols
    kableExtra::column_spec(
      column = c(length(cols_id) + 1:6),
      border_right = "2px solid #f7f7f7"
    ) |>
    kableExtra::kable_styling(
      bootstrap_options = c("condensed", "hover"), # "responsive"
      full_width = FALSE,
      position = "left",
      font_size = 11
    ) |>
    kableExtra::collapse_rows(
      columns = seq_along(cols_id),
      valign = "top"
    ) |>
    kableExtra::add_header_above(
      header = c(
        " " = length(cols_id),
        "scope" = grepl("scope", colnames(data_table_wide)) |> sum(),
        " " = length(cols_addon)
      ),
      extra_css = "border-bottom: 1.5px solid"
    ) |>
    kableExtra::row_spec(
      row = 0 ,
      # align headers top 
      extra_css = 'vertical-align: top !important; padding: 8px;'
    ) |>
    kableExtra::row_spec(
      row = 1:nrow(data_table_wide),
      # row height
      extra_css = 'padding: 4px;'
    ) |>
    kableExtra::footnote(
      symbol = footnote_data$scope_motivation,
      symbol_manual = footnote_data$scope_verbose,
      escape = FALSE
    ) 
}

```


## Approach

### Potential surveillance/monitoring schemes for IAS

Following the EU IAS regulation, the IAS of (future) union concern can in theory be subjected to surveillance/monitoring schemes of different scopes.
We distinguish 6 surveillance/monitoring scopes:

- Detection
- Inventory
- (Change in) Distribution
- (Change in) Abundance
- (Change in) Distribution after management
- (Change in) Abundance after management

We employ the following working definitions:


::: {.callout-note icon="false"}
## Detection

- *Purpose*:
    - Early identification of new invasive species in Flanders
    - Maximize chance of detection (through probability of presence and probability of detection)
    - Enable rapid responses
- *Methods*:
    - *high sensitivity* required relative to costs; this can also be high sensitivity accumulated over repeated measurements if costs are very low
    - *high specificity* not required as false positives less problematic than false negatives; some procedure of confirmation of initial detections needs to be in place though
    - provide at least presence/absence information
    - e.g., eDNA, remote sensing methods
- *Spatial and temporal coverage/resolution*:
    - focused surveillance area at/around known/potential places of introduction and sites of sporadic occurrence; possibly also in/around conservation area
    - complemented by broad (scale of Flanders?) "surveillance" via opportunistic observations?
    - near-continuous measurement in space and time; this can but need not be achieved through high spatial/temporal frequency sampling: methods with low costs and/or sampling effort (e.g., remote sensing) can be used with dense sampling schemes; methods that have lower specificity in time and space (e.g., eDNA) could substitute for near-continuous sampling

:::

::: {.callout-note icon="false"}
## Inventory
Definition here.
:::

::: {.callout-note icon="false"}
## (Change in) Distribution
Definition here.
:::


::: {.callout-note icon="false"}
## (Change in) Abundance
Definition here.
:::

::: {.callout-note icon="false"}
## (Change in) Distribution after management
Definition here.
:::

::: {.callout-note icon="false"}
## (Change in) Abundance after management
Definition here.
:::


Combining the IAS of union concern (here species A - N for purposes of illustration) with all surveillance/monitoring scopes results in a table of *potential combinations* of the form:


```{r show-empty-table}
#| results: asis
#| classes: .center-table
#| 
table_base_illu_list_upd$stadium |> 
  dplyr::mutate(
    scope_verbose = NA_character_
  )|>
  dplyr::arrange(species) |>
  make_table_display(
    data_table = _,
    cols_id = c("species"),
    cols_addon = NULL,
    footnote = NULL) |> 
  unclass() |> cat()


```

### Limiting the number of species-scheme combinations

Our aim is to fill this table - with a limited number of *relevant and/or feasible* and *high priority* species-surveillance/monitoring scheme combinations.
Hence we want to obtain sparse variants of the above table as a first component of the plan of action. 
This will then give rise to a concrete suggestion for the steering committee (e.g., ~3 species groups for which we will start designing the respective surveillance/monitoring schemes using the INBO-guidelines). 

To arrive at such a table variant, the *following steps* are proposed.
We thereby mainly rely on the information gathered via the expert survey on IAS in Flanders.
Complementing the expert judgements with additional information will probably be required occasionally.

- **Step 1**: **Indicate cells that will definitively not be covered**, because...
    - ... a *scope is irrelevant* for a species (e.g., detection is the only relevant scope for absent species, detection in conservation areas is only needed if a species is absent from the conservation area, if a species is not managed then monitoring after management is not needed)
    - ... there is *no method available* to implement a scope (e.g., if available methods can only measure presence/absence of a species, but not numbers, abundance cannot be monitored)
- **Step 2**:  **Obtain a ‘base’ table**
    - Fill the remaining cells with the *reported methods* and *existing surveillance/monitoring schemes*
- **Step 3**: **Indicate cells that have higher vs. lower priority**
    - e.g., species that reach a *critical urgency and feasibility* value can be given priority
- **Step 4**: **Look for synergies based on method-overlap within scopes**
    - Between *prior* species, as well as between *prior and non-prior* species

In the following, we detail these steps and provide a schematic illustration of how the initially presented table will change.


### Details and demonstration of approach

```{r make-base-table-illustration}
#| cache: false

table_base_illu_list_display <- mapply(
  \(table, index) {
    table |> 
      dplyr::arrange(stadium, species) |>
      make_table_display(
        data_table = _,
        cols_id = c("species", "stadium"),
        cols_addon = NULL,
        footnote_data = footnote_base[1:index,] |>
          # color last row of footnote data
          dplyr::mutate(
            dplyr::across(
              tidyselect::starts_with("scope"),
              \(y) dplyr::case_when(
                dplyr::row_number() == dplyr::n() ~ kableExtra::cell_spec(x = y, color = color_hl),
                TRUE ~ y
              )
            )
          )
      )
  },
  table_base_illu_list_upd,
  table_base_illu_list_upd |> seq_along(),
  SIMPLIFY = FALSE
)

```


#### Step 1: Indicate cells that will definitively not be covered

In Step 1, we mark cells that are *definitively not covered*. 
One reason for a cell not being covered is that the respective *scope is irrelevant* for a species. 
We determine scope relevance based on ... 

- the invasion stadium of a species, 
- whether the surveillance/monitoring area is known, 
- whether the species is managed,
- which information is necessary to evaluate management.

Another reason for a cell not being covered is that there are no suitable methods available to implement the scope.

We explain and illustrate each component of Step 1 in the following.
For the exact filtering rules applied to the survey data see [here](https://github.com/inbo/mias-general/blob/b5c6d5bdccdb77f97c0c42874f5524f57d856ebc/source/export/survey_experts/08_make_priority_tables.R#L226-L292).

##### Invasion stadium

First and foremost, scope relevance depends on *invasion stadium*.
Depending on the invasion stadium (in conservation areas) only certain scopes make sense:

- For **absent species**, the (potential) scope is detection (ideally) at / around places of introduction
- For **sporadically present species** the (potential) scope is detection (ideally) at / around places of introduction and known sites  
- For **limited established species**, the (potential) scopes are
    - inventory,
    - (change in) distribution (after management) at / around places of distribution and/or management,
    - (change in) abundance (after management) at places of distribution and/or management
- For **widely established species**, the (potential) scopes are
    - detection in conservation areas if the species is not yet present/established there and is expected to have an impact,
    - (change in) distribution (after management) at and around places of distribution and/or management,
    - (change in) abundance (after management) at places of distribution and/or management;
    - inventory is not considered as the distribution of widely established species is generally known (see survey results so far)

Having considered the invasion stadium the table looks like this:


```{r show-base-table-illustration-stadium}
#| results: asis
#| classes: .center-table

# https://github.com/quarto-dev/quarto-cli/issues/1710
table_base_illu_list_display$stadium |> unclass() |> cat()

```

<br>

##### Surveillance/monitoring area being (un-)known

Second, scope relevance also depends on whether the *surveillance/monitoring area is known* for a species. 
At this stage, we only consider *limited established species* here. 

- If the **distribution area is reported as known**, then the scope inventory is irrelevant.
- If the **distribution area is unknown**, inventory is relevant, and we also keep the distribution and abundance-related scopes for now and reconsider them later (see step 3)

Having considered whether the surveillance/monitoring area is known the table looks like this:

```{r show-base-table-illustration-area}
#| results: asis
#| classes: .center-table

table_base_illu_list_display$area |> unclass() |> cat()

```

<br>

##### Existence of management

A third factor to determine scope relevance is the *existence of management*.

- If a **species is not managed**, then management-related monitoring is irrelevant.

Having considered which species are managed the table looks like this:

```{r show-base-table-illustration-managementexists}
#| results: asis
#| classes: .center-table

table_base_illu_list_display$management_exists |> unclass() |> cat()

```

<br>

##### Evaluation of management

Fourth, scope relevance depends on the *kind of information necessary to evaluate management* (if the species is managed).

- If **presence-absence information is sufficient**, then management-related monitoring using abundance information is irrelevant
- If **abundance information is required**, then management-related monitoring using distribution information is irrelevant

Having considered the evaluation of management the table looks like this:

```{r show-base-table-illustration-managementeval}
#| results: asis
#| classes: .center-table


table_base_illu_list_display$management_eval |> unclass() |> cat()

```

<br>

##### Suitable methods

While a scope might remain relevant for a species after considering the above-discussed components, 
a cell might still not being covered because there are no *suitable methods* available to implement the scope.
At this stage, we consider a method not suitable, if it *cannot measure the desired outcome*:

- If a method reported in the survey can **only measure presence-absence** but not relative/absolute abundance of a species,
the scopes related to abundance become infeasible

Having considered the suitability of methods the table looks like this:


```{r show-base-table-illustration-5}
#| results: asis
#| classes: .center-table

table_base_illu_list_display$method |> unclass() |> cat()

```

#### Step 2: Obtain a ‘base’ table

To obtain a ‘base’ table in Step 2, we can now fill the remaining cells with the *reported surveillance/monitoring methods*.
In addition, we can provide *existing surveillance/monitoring schemes* (potentially) meeting the respective surveillance/monitoring scope (not illustrated here).

The base table looks like this:

```{r show-base-table-illustration-6}
#| results: asis
#| classes: .center-table

table_base_illu_list_upd |> 
  dplyr::last() |>
  dplyr::mutate(
    scope_verbose = dplyr::case_when(
      scope_boolean == 1 ~ method_all,
      TRUE ~ scope_verbose
    ),
    # don't highlight symbol
    scope_verbose = gsub(
      color_hl |> grDevices::col2rgb() |> as.vector() |> append(255) |> 
        paste(x = _, collapse = ", "), 
      "black" |> grDevices::col2rgb() |> as.vector() |> append(255) |> 
        paste(x = _, collapse = ", "), 
      scope_verbose)
  ) |>
  dplyr::arrange(stadium, species) |>
  make_table_display(
    data_table = _,
    cols_id = c("species", "stadium"),
    cols_addon = NULL,
    footnote_data = footnote_base
  ) |> 
  unclass() |> cat()

```


#### Step 3: Indicate cells with higher vs. lower priority


```{r make-filtered-table-illustration}
#| cache: false

table_filtered_illu_list_display <- mapply(
  \(table, index) {
    table |>
      dplyr::arrange(stadium, species) |>
      make_table_display(
        data_table = _,
        cols_id = c("species", "stadium"),
        cols_addon = NULL,
        footnote_data = footnote_filtered[1:index,] |>
          # color last row of footnote
          dplyr::mutate(
            dplyr::across(
              tidyselect::starts_with("scope"),
              \(y) dplyr::case_when(
                dplyr::row_number() == dplyr::n() ~ kableExtra::cell_spec(x = y, color = color_hl),
                TRUE ~ y
              )
            )
          )
      )
  },
  table_filtered_illu_list_upd,
  table_filtered_illu_list_upd |> seq_along(),
  SIMPLIFY = FALSE
)

```


In Step 3, we further filter the base table (i.e., distinguish cells with high vs. low priority). 
To filter, we currently propose to use the following criteria:

- whether or not existing surveillance/monitoring schemes or opportunistic/unstructured observations cover the relevant/feasible scopes
- whether or not the surveillance/monitoring area is known for a species
- whether the expert-judged global feasibility and urgency reaches a critical value

We again explain and illustrate each component of Step 3 in the following.
For the exact filtering rules applied to the survey data see [here](https://github.com/inbo/mias-general/blob/b5c6d5bdccdb77f97c0c42874f5524f57d856ebc/source/export/survey_experts/08_make_priority_tables.R#L293-L340).



##### Existing surveillance/monitoring schemes and opportunistic observations

First, we check whether species-scope combinations can be considered covered by *existing surveillance/monitoring schemes* or *opportunistic/unstructured observations* (i.e., waarnemingen.be).

- Cells for which **existing surveillance schemes meet the respective scope** are marked as having low priority (not yet implemented)
- Cells associated with species for which **opportunistic observations are considered representative** are marked as having low priority

Having considered the representativeness of opportunistic observations the table looks like this:

```{r show-filtered-table-illustration-observation}
#| results: asis
#| classes: .center-table

table_filtered_illu_list_display$observation |> unclass() |> cat()

```

<br>

##### Surveillance/monitoring area being (un-)known

Second, we (again) take into account whether the *surveillance/monitoring area is known* for a species. 
If the area is reported as unknown the following cells are marked as having low priority.

- For **absent species** the detection scope is marked as having low priority if the introduction places are reported as unknown
- For **sporadically present species** the detection scope is marked as having low priority if the introduction places or the distribution area are reported as unknown
- For **limited established species**, if the distribution area is reported as unknown, 
    - the distribution- and abundance-related scopes are marked as low priority (conditional on inventory), 
    - while the inventory scope is marked as high priority

Having considered whether the surveillance/monitoring area is known the table looks like this:


```{r show-filtered-table-illustration-area}
#| results: asis
#| classes: .center-table

table_filtered_illu_list_display$area |> unclass() |> cat()

```

<br>

##### Global priority score

Finally, we consider the survey’s global priority scores reflecting the *expert-judged global feasibility and urgency per species*. 
For now we calculate these scores as the grand mean across all scored questions per species, which means that each question gets the same weight.

- One (or even multiple) critical value(s) can be defined in an absolute or relative (percentile) manner. 
    - Currently, the median is employed as as a critical value(s) 
- Cells associated with species that *do not reach the critical value* are marked as having low priority

Having considered the global prirority score the table looks like this:


```{r show-filtered-table-illustration-globalscore}
#| results: asis
#| classes: .center-table

table_filtered_illu_list_display$globalscore |> unclass() |> cat()

```


#### Step 4: Look for synergies

Finally we aim to *group species based on synergies*. 
For now we consider synergies in *designing* different surveillance/monitoring schemes (e.g., researching methods, planning sampling independent of the concrete sampling sites). We do at this stage not consider synergies that might purely arise during the implementation of the surveillance/monitoring scheme (e.g., overlap in concrete sampling sites). 
We expect the design-synergies to mainly be driven by method overlap between species within scopes. 

Synergies can occur... 

- ... between prior species resulting in groups with multiple prior species,
- ... between prior and non-prior species. In this case we...
    - ... indicate non-prior species that are potential ‘free riders’ under surveillance/monitoring schemes for prior species.
    - One priority species per group can thereby be sufficient.


Starting from the filtered table...

```{r show-filtered-table-illustration-final}
#| results: asis
#| classes: .center-table

table_filtered_illu_final <- table_filtered_illu_list_upd |> 
  dplyr::last() |>
  dplyr::mutate(
    # don't highlight symbol
    scope_verbose = gsub(
      color_hl |> grDevices::col2rgb() |> as.vector() |> append(255) |> 
        paste(x = _, collapse = ", "), 
      "black" |> grDevices::col2rgb() |> as.vector() |> append(255) |> 
        paste(x = _, collapse = ", "), 
      scope_verbose)
  ) |>
  dplyr::arrange(stadium, species) 
table_filtered_illu_final |>
  make_table_display(
    data_table = _,
    cols_id = c("species", "stadium"),
    cols_addon = NULL,
    footnote_data = footnote_filtered
  ) |> unclass() |> cat()

```


... we have highlighted method-synergies within the scope distribution.

```{r show-synergies}
#| results: asis
#| classes: .center-table

table_filtered_illu_final |>
  dplyr::mutate(
    scope_verbose = dplyr::case_when(
      grepl("distribution$", scope_type) & grepl("high", scope_prior) & grepl("methode A", method_all) ~ 
        kableExtra::cell_spec(x = method_all, color = color_meth_a, bold = TRUE),
      grepl("distribution$", scope_type) & grepl("high", scope_prior) & grepl("methode B", method_all) ~ 
        kableExtra::cell_spec(x = method_all, color = color_meth_b, bold = TRUE),
      TRUE ~ scope_verbose
    )
  ) |>
  make_table_display(
    data_table = _,
    cols_id = c("species", "stadium"),
    cols_addon = NULL,
    footnote_data = footnote_filtered
  ) |> unclass() |> cat()

```



## Base tables

```{r sort-base-table}

table_base_upd <- table_base_upd |>
  dplyr::arrange(
    scope_boolean |> dplyr::desc(), 
    scope_type, 
    prius_milieu,
    stadium,
    m_score |> dplyr::desc()
  ) 

``` 

The following base tables for plants and animals are sorted as follows:

- First, rows are sorted by scope type relying on the order of the table columns: `r table_base_upd$scope_type |> levels()`.
    - That is, all species for which (at least) detection is relevant/feasible appear first, 
followed by those for which (at least) inventory is relevant/feasible, 
followed by those for which (at least) inventory is relevant/feasible etc., resulting in a stair step (?)/ blocked pattern.
- Within (i.e., for each value of) scope type, rows are sorted by milieu according to the order: `r table_base_upd$prius_milieu |> levels()`.
- Within (i.e., for each value of) milieu, rows are sorted by invasion stadium, from "absent" to "widely established".
- Within (i.e., for each value of) invasion stadium, rows are sorted by priority score from high to low.


### Plants

```{r make-base-table-display-plants}
#| results: asis
#| cache: false
#| classes: .center-table

table_base_upd |>
  dplyr::filter(grepl("plant", kingdom)) |>
  make_table_display(
    data_table = _,
    cols_id = c("species", "vern_name_nld", "prius_milieu", "stadium"),
    cols_addon = c("m_score"),
    footnote_data = footnote_base
  ) |> unclass() |> cat()

```

### Animals

```{r make-base-table-display-animals}
#| results: asis
#| cache: false
#| classes: .center-table

table_base_upd |>
  dplyr::filter(grepl("dier", kingdom)) |>
  make_table_display(
    data_table = _,
    cols_id = c("species", "vern_name_nld", "prius_milieu", "stadium"),
    cols_addon = c("m_score"),
    footnote_data = footnote_base
  ) |> unclass() |> cat()

```


## Filtered tables


```{r sort-filtered-table}

table_filtered_upd <- table_filtered_upd |>
  dplyr::arrange(
    scope_prior, 
    scope_type, 
    prius_milieu,
    stadium,
    m_score |> dplyr::desc()
  ) 

``` 

The following filtered tables for plants and animals are sorted similarly to the base tables:

- First, rows are sorted by scope priority, with high priority scopes on top.
- Within (i.e., for each value of) scope priority, rows are sorted by scope type relying again on the order: `r table_base_upd$scope_type |> levels()`.
    - That is, within the high/low priority scopes, all species for which (at least) detection is relevant/feasible appear first, 
followed by those for which (at least) inventory is relevant/feasible, 
followed by those for which (at least) inventory is relevant/feasible etc..
- Within (i.e., for each value of) scope type, rows are again sorted by milieu according to the above order: `r table_base_upd$prius_milieu |> levels()`.
- Within (i.e., for each value of) milieu, rows are again sorted by invasion stadium, from "absent" to "widely established".
- Within (i.e., for each value of) invasion stadium, rows are again sorted by priority score from high to low.



### Plants

```{r make-filtered-table-display-plants}
#| results: asis
#| cache: false
#| classes: .center-table

table_filtered_upd |>
  dplyr::filter(grepl("plant", kingdom)) |>
  make_table_display(
    data_table = _,
    cols_id = c("species", "vern_name_nld", "prius_milieu", "stadium"),
    cols_addon = c("m_score"),
    footnote_data = footnote_combined
  ) |> unclass() |> cat()

```

### Animals

```{r make-filtered-table-display-animals}
#| results: asis
#| cache: false
#| classes: .center-table

table_filtered_upd |>
  dplyr::filter(grepl("dier", kingdom)) |>
  make_table_display(
    data_table = _,
    cols_id = c("species", "vern_name_nld", "prius_milieu", "stadium"),
    cols_addon = c("m_score"),
    footnote_data = footnote_combined
  ) |> unclass() |> cat()

```

## Synergies


### Animals

```{r synergies-animals-prep}
#| warning: false
#| message: false
#| 
table_filtered_animals <- table_filtered_upd |> 
  dplyr::filter(grepl("dier", kingdom) & grepl("highprior", scope_prior)) 
methods_animals <- setNames(
  object = table_filtered_animals$method_all |> unique() |> as.list(),
  nm = table_filtered_animals$method_all |> unique() |> 
    gsub("\\:", "", x = _) |> gsub("\\s", "_", x = _)
)
#
# reshape to dataframe with species list per scope type and method
table_grouped_animals <- lapply(
  as.list(methods_animals),
  function(table, method) {
    table |> 
      tidyr::pivot_wider(
        id_cols = c(scope_type, prius_milieu),
        names_from = method_all,
        values_from = species
      ) |> 
      dplyr::select(
        tidyselect::all_of(c("scope_type", "prius_milieu", method))
      ) |>
      tidyr::unnest(data = _, cols = method) |>
      dplyr::rename( species = method) |> 
      dplyr::mutate(
        method = method,
        n_species = dplyr::n(),
        .by = scope_type
      )
  },
  table = table_filtered_animals
) |> 
  dplyr::bind_rows() |>
  dplyr::left_join(
    x = _,
    y = table_filtered_animals |> 
      dplyr::distinct(species, vern_name_nld)
  )
#
# arrange according to scope_type and n_species in method
table_grouped_animals <- do.call(
  what = factorize, 
  args = args_factorize |> append(list(dataframe = table_grouped_animals))
  ) |>
  dplyr::arrange(
    scope_type,
    n_species |> dplyr::desc()
  )
# 
# reshape to list containing a (species , milieu) x methods data frame per scope 
scope_type_list <- setNames(
  object = table_grouped_animals$scope_type |> levels() |> as.list(),
  nm = table_grouped_animals$scope_type |> levels()
)
table_grouped_animals_list <- lapply(
  scope_type_list, 
  function(scope, table){
    table |> 
      dplyr::filter(scope_type == scope) |>
      tidyr::pivot_wider(
        id_cols = c(scope_type, species, vern_name_nld, prius_milieu),
        names_from = method,
        names_prefix = "method_",
        values_from = n_species
      )
  },
  table = table_grouped_animals
)

```

```{r define-function-make-table-synergies-display}

make_table_syn_display <- function(
    data_table,
    cols_id = c(
      "species",
      "vern_name_nld",
      "prius_milieu"
    )
) {
  
  table_i <- data_table |>
    dplyr::select(-scope_type) |>
    dplyr::arrange(prius_milieu) |>
    dplyr::mutate(
      dplyr::across(
        tidyselect::starts_with("method_"),
        \(x) dplyr::case_when(
          !is.na(x) ~ kableExtra::cell_spec(
            x = x,
            color = "white",
            background = color_hl
          ),
          TRUE ~ NA_character_
        )
      )
    ) 
  colnames_upd <- c(
    colnames(table_i)[seq_along(cols_id)],
    colnames(table_i)[(length(cols_id) + 1): ncol(table_i)] |> 
      gsub(pattern = "method_", replacement = "", x = _)
  )
  table_i |>
    knitr::kable(
      x = _,
      format = "html",
      escape = FALSE,
      col.names = colnames_upd,
      table.attr = 'data-quarto-disable-processing="true"' # if quarto HERE
    ) |>
    # background of id cols
    kableExtra::column_spec(
      column = seq_along(cols_id),
      background = "grey97",
      width_min = "220px",
    ) |>
    # borders of method cols
    #  width
    kableExtra::column_spec(
      column = (length(cols_id) + 1):ncol(table_i),
      width_min = "20px",
      width_max = "20px",
      include_thead = TRUE,
      border_right = "2px solid #f7f7f7"
    ) |>
    kableExtra::kable_styling(
      bootstrap_options = c("condensed", "hover"), # "responsive"
      full_width = FALSE,
      position = "left",
      font_size = 11
    ) |>
    kableExtra::collapse_rows(
      columns = seq_along(cols_id),
      valign = "top"
    ) |>
    kableExtra::add_header_above(
      header = c(
        " " = 3,
        "method" = ncol(table_i) - length(cols_id)
      ),
      extra_css = "border-bottom: 1.5px solid"
    ) |>
    kableExtra::row_spec(
      row = 0,
      extra_css = 
      "writing-mode: vertical-lr;  transform: rotate(180deg); white-space: nowrap; padding: 5px;"
    ) |>
    kableExtra::row_spec(
      row = 1:nrow(table_i),
      # row height
      extra_css = 'padding: 4px;'
    )  
}


```


```{r synergies-animals-make-tables}
#| warning: false
#| message: false
#| cache: false

table_grouped_animals_display_list <- lapply(
  scope_type_list,
  \(x) make_table_syn_display(data_table = table_grouped_animals_list[[x]])
)

```

#### Synergies between high-priority species

Per surveillance/monitoring scope, the following tables reveal method-related synergies between species.
If a species is covered by one of the methods reported for the respective scope, the table cell is filled and the total number of species covered by that method is displayed.

We might use these tables to identify the x largest species groups covered by the same method within similar habitats.
For these x groups we could proceed with the detailed planning of surveillance/monitoring schemes.

<br>

##### Scope detection


```{r synergies-animals-display-detection}
#| results: asis
#| cache: false
#| eval: true

table_grouped_animals_display_list$detection 

```

- We see that **eDNA** is suited for the detection of 8 species (crayfish, fish, 1 mammal) that occur in (partly) **freshwater** habitats
    - **Electrofishing** and/or **trapping** could be used for putting positive findings to a more specific test
- Also, **visual surveys** are suited for the detection of 5 (6-1) (partly) **terrestrial** species
- Finally, **cameratraps** are suited for the detection of 3 (partly) **terrestrial** species

<br>

##### Scope inventory

```{r synergies-animals-display-inventory}
#| results: asis
#| cache: false
#| classes: .center-table
#| eval: true

table_grouped_animals_display_list$inventory

```

- This inventory will be a result of craywatch

<br>

##### Scope distribution

```{r synergies-animals-display-distribution}
#| results: asis
#| cache: false
#| classes: .center-table
#| eval: true

table_grouped_animals_display_list$distribution

```

- We see that **visual surveys** could be used for at least 5 (partly) **terrestrial** species
- Also, **eDNA** is suited for determining the distribution of 6 species that occur in (partly) **freshwater** habitats (1 amphibian, 1 crayfish, 1 fish, 1 crab, 2 mammals)
    - the method could again be backed-up by **electrofishing** and/or **trapping** (in case of the non-mammals) or by **camera traps** (in case of the mammals)
- Finally, **camera traps** could also be used for 5 (partly) **terrestrial** species

<br>

##### Scope abundance

```{r synergies-animals-display-abundance}
#| results: asis
#| cache: false
#| classes: .center-table
#| eval: true

table_grouped_animals_display_list$abundance

```

- We see that **visual surveys** are suited to determine the abundance of 2 **terrestrial** species
- Also, **eDNA** is suited to determine the abundance of 3 (partly) **freshwater** species (1 amphibian, 1 crab, 1 fish) 
- Also, **trapping** is suited to determine the abundance of 3 (partly) **freshwater** species
- Also, **electrofishing** is suited to determine the abundance of 3 (partly) **freshwater** species (1 amphibian, 1 fish, 1 crab)

<br>

##### Scope distribution after management

```{r synergies-animals-display-distribution-management}
#| results: asis
#| cache: false
#| classes: .center-table
#| eval: true

table_grouped_animals_display_list$distribution_management

```

- We see that **visual surveys** are suited to determine the distribution after management of 2 (partly) **terrestrial** species
- Also, **camera traps** are suited to determine the distribution after management of 2 (partly) **terrestrial** species

<br>

##### Scope abundance after management

```{r synergies-animals-display-abundance-management}
#| results: asis
#| cache: false
#| classes: .center-table
#| eval: true

table_grouped_animals_display_list$abundance_management

```

- We see that **visual surveys** are suited to determine the abundance after management of 2 **terrestrial** species
- Also, **eDNA** is suited to determine the abundance after management of 2 (partly) **freshwater** species (1 amphibian, 1 crab) 
- Also, **trapping** is suited to determine the abundance after management of 2 (partly) **freshwater** species 
- Also, **camera traps** are suited to determine the abundance after management of 2 **terrestrial** species

<br>

#### Synergies between high- and low-priority species

Once we have identified x high-priority species groups to tackle, we can search for method-related synergies between the chosen high-priority and low-priority species.

