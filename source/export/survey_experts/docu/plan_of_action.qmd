---
title: "Plan of action"
author: "Janne Adolf, Diederik Strubbe, Tim Adriaens, Thierry Onkelinx"
format: 
  html:
    toc: true
    toc-location: left-body
    toc-depth: 3
    toc-expand: true
    theme: yeti
    number-sections: true
    number-depth: 3
    embed-resources: true
execute: 
  eval: true
  echo: false
  cache: false
---

```{r format-priority-tables}

response_data_path <- "../../../../data/survey_experts/"
functions_path <- "../../../functions"
source("../09_format_priority_tables.R", local = knitr::knit_global())

``` 


## Approach

### Potential surveillance/monitoring schemes for IAS

Following the EU IAS regulation, the IAS of (future) union concern can in theory be subjected to surveillance/monitoring schemes of different scopes.
We distinguish 6 surveillance/monitoring scopes:

- Detection
- Inventory
- (Change in) Distribution
- (Change in) Abundance
- (Change in) Distribution after management
- (Change in) Abundance after management

We employ the following working definitions:


::: {.callout-note icon="false"}
## Detection

- *Purpose*:
- Early identification of new invasive alien species
- Maximize chance of detection (through probability of presence and probability of detection)
- Enable rapid responses
- *Methods*:
- *high sensitivity* required relative to costs; this can also be high sensitivity accumulated over repeated measurements if costs are very low
- *high specificity* not required as false positives less problematic than false negatives; some procedure of confirmation of initial detections needs to be in place though
- provide at least presence/absence information
- e.g., eDNA, remote sensing methods
- *Spatial and temporal coverage/resolution*:
- focused surveillance area at/around known/potential places of introduction and sites of sporadic occurrence; possibly also in/around conservation area
- complemented by broad (scale of Flanders?) "surveillance" via opportunistic observations?
- near-continuous measurement in space and time; this can but need not be achieved through high spatial/temporal frequency sampling: methods with low costs and/or sampling effort (e.g., remote sensing) can be used with dense sampling schemes; methods that have lower specificity in time and space (e.g., eDNA) could substitute for near-continuous sampling

:::

::: {.callout-note icon="false"}
## Inventory
Definition here.
:::

::: {.callout-note icon="false"}
## (Change in) Distribution

- *Purpose*:
- Assessing the status (and trend) of the spatial distribution of an invasive alien species
- ...

:::


::: {.callout-note icon="false"}
## (Change in) Abundance

- *Purpose*:
- Assessing the status (and trend) of the population size of an invasive alien species in its distribution area
- ...

:::

::: {.callout-note icon="false"}
## (Change in) Distribution after management

- *Purpose*:
- Assessing the status (and trend) of the spatial distribution of an invasive alien species within a defined area after managment has taken place
- ...

:::

::: {.callout-note icon="false"}
## (Change in) Abundance after management

- *Purpose*:
- Assessing the status (and trend) of the population size of an invasive alien species within a defined area after managment has taken place
- ...

:::


Combining the IAS of union concern (here species A - N for purposes of illustration) with all surveillance/monitoring scopes results in a table of *potential combinations* of the form:


```{r show-empty-table}
#| results: asis
#| classes: .center-table
#| 
table_base_illu_list_upd$stadium |> 
  dplyr::mutate(
    scope_verbose = NA_character_
  )|>
  dplyr::arrange(species) |>
  make_table_display(
    data_table = _,
    cols_id = c("species"),
    cols_addon = NULL,
    footnote = NULL) |> 
  unclass() |> cat()


```

### Limiting the number of species-scheme combinations

Our aim is to fill this table - with a limited number of *relevant and/or feasible* and *high priority* species-surveillance/monitoring scheme combinations.
Hence we want to obtain sparse variants of the above table as a first component of the plan of action. 
This will then give rise to a concrete suggestion for the steering committee (e.g., ~3 species groups for which we will start designing the respective surveillance/monitoring schemes using the INBO-guidelines). 

To arrive at such a table variant, the *following steps* are proposed.
We thereby mainly rely on the information gathered via the expert survey on IAS in Flanders.
Complementing the expert judgements with additional information will probably be required occasionally.

- **Step 1**: **Indicate cells that will definitively not be covered**, because...
- ... a *scope is irrelevant* for a species (e.g., detection is the only relevant scope for absent species, detection in conservation areas is only needed if a species is absent from the conservation area, if a species is not managed then monitoring after management is not needed)
- ... there is *no method available* to implement a scope (e.g., if available methods can only measure presence/absence of a species, but not numbers, abundance cannot be monitored)
- **Step 2**:  **Obtain a ‘base’ table**
- Fill the remaining cells with the *reported methods* and *existing surveillance/monitoring schemes*
- **Step 3**: **Indicate cells that have higher vs. lower priority**
- e.g., species that reach a *critical urgency and feasibility* value can be given priority
- **Step 4**: **Look for synergies based on method-overlap within scopes**
- Between *prior* species, as well as between *prior and non-prior* species

In the following, we detail these steps and provide a schematic illustration of how the initially presented table will change.


### Details and demonstration of approach

```{r make-base-table-illustration}
#| cache: false

table_base_illu_list_display <- mapply(
  \(table, index) {
    table |> 
      dplyr::arrange(stadium, species) |>
      make_table_display(
        data_table = _,
        cols_id = c("species", "stadium"),
        cols_addon = NULL,
        footnote_data = footnote_base[1:index,] |>
          # color last row of footnote data
          dplyr::mutate(
            dplyr::across(
              tidyselect::starts_with("scope"),
              \(y) dplyr::case_when(
                dplyr::row_number() == dplyr::n() ~ kableExtra::cell_spec(x = y, color = color_hl),
                TRUE ~ y
              )
            )
          )
      )
  },
  table_base_illu_list_upd,
  table_base_illu_list_upd |> seq_along(),
  SIMPLIFY = FALSE
)

```


#### Step 1: Indicate cells that will definitively not be covered

In Step 1, we mark cells that are *definitively not covered*. 
One reason for a cell not being covered is that the respective *scope is irrelevant* for a species. 
We determine scope relevance based on ... 

- the invasion stadium of a species, 
- whether the surveillance/monitoring area is known, 
- whether the species is managed,
- which information is necessary to evaluate management.

Another reason for a cell not being covered is that there are no suitable methods available to implement the scope.

We explain and illustrate each component of Step 1 in the following.
For the exact filtering rules applied to the survey data see [here](https://github.com/inbo/mias-general/blob/b5c6d5bdccdb77f97c0c42874f5524f57d856ebc/source/export/survey_experts/08_make_priority_tables.R#L226-L292).

##### Invasion stadium

First and foremost, scope relevance depends on *invasion stadium*.
Depending on the invasion stadium (in conservation areas) only certain scopes make sense:

- For **absent species**, the (potential) scope is detection (ideally) at / around places of introduction
- For **sporadically present species** the (potential) scope is detection (ideally) at / around places of introduction and known sites  
- For **limited established species**, the (potential) scopes are
- inventory,
- (change in) distribution (after management) at / around places of distribution and/or management,
- (change in) abundance (after management) at places of distribution and/or management
- For **widely established species**, the (potential) scopes are
- detection in conservation areas if the species is not yet present/established there and is expected to have an impact,
- (change in) distribution (after management) at and around places of distribution and/or management,
- (change in) abundance (after management) at places of distribution and/or management;
- inventory is not considered as the distribution of widely established species is generally known (see survey results so far)

Having considered the invasion stadium the table looks like this:


```{r show-base-table-illustration-stadium}
#| results: asis
#| classes: .center-table

# https://github.com/quarto-dev/quarto-cli/issues/1710
table_base_illu_list_display$stadium |> unclass() |> cat()

```

<br>

##### Surveillance/monitoring area being (un-)known

Second, scope relevance also depends on whether the *surveillance/monitoring area is known* for a species. 
At this stage, we only consider *limited established species* here. 

- If the **distribution area is reported as known**, then the scope inventory is irrelevant.
- If the **distribution area is unknown**, inventory is relevant, and we also keep the distribution and abundance-related scopes for now and reconsider them later (see step 3)

Having considered whether the surveillance/monitoring area is known the table looks like this:

```{r show-base-table-illustration-area}
#| results: asis
#| classes: .center-table

table_base_illu_list_display$area |> unclass() |> cat()

```

<br>

##### Existence of management

A third factor to determine scope relevance is the *existence of management*.

- If a **species is not managed**, then management-related monitoring is irrelevant.

Having considered which species are managed the table looks like this:

```{r show-base-table-illustration-managementexists}
#| results: asis
#| classes: .center-table

table_base_illu_list_display$management_exists |> unclass() |> cat()

```

<br>

##### Evaluation of management

Fourth, scope relevance depends on the *kind of information necessary to evaluate management* (if the species is managed).

- If **presence-absence information is sufficient**, then management-related monitoring using abundance information is irrelevant
- If **abundance information is required**, then management-related monitoring using distribution information is irrelevant

Having considered the evaluation of management the table looks like this:

```{r show-base-table-illustration-managementeval}
#| results: asis
#| classes: .center-table


table_base_illu_list_display$management_eval |> unclass() |> cat()

```

<br>

##### Suitable methods

While a scope might remain relevant for a species after considering the above-discussed components, 
a cell might still not being covered because there are no *suitable methods* available to implement the scope.
At this stage, we consider a method not suitable, if it *cannot measure the desired outcome*:

- If a method reported in the survey can **only measure presence-absence** but not relative/absolute abundance of a species,
the scopes related to abundance become infeasible
- Strictly speaking, we only have this information of the 'most relevant' but not other methods listed; here we take a conservative approach assuming that if the 'most relevant' method cannot measure abundance then none of the other methods can (debatable)

Having considered the suitability of methods the table looks like this:


```{r show-base-table-illustration-5}
#| results: asis
#| classes: .center-table

table_base_illu_list_display$method |> unclass() |> cat()

```

#### Step 2: Obtain a ‘base’ table

To obtain a ‘base’ table in Step 2, we can now fill the remaining cells with the *reported surveillance/monitoring methods*.
In addition, we can provide *existing surveillance/monitoring schemes* (potentially) meeting the respective surveillance/monitoring scope (not illustrated here).

The base table looks like this:

```{r show-base-table-illustration-6}
#| results: asis
#| classes: .center-table

table_base_illu_list_upd |> 
  dplyr::last() |>
  dplyr::mutate(
    scope_verbose = dplyr::case_when(
      scope_boolean == 1 ~ method_all,
      TRUE ~ scope_verbose
    ),
    # don't highlight symbol
    scope_verbose = gsub(
      color_hl |> grDevices::col2rgb() |> as.vector() |> append(255) |> 
        paste(x = _, collapse = ", "), 
      "black" |> grDevices::col2rgb() |> as.vector() |> append(255) |> 
        paste(x = _, collapse = ", "), 
      scope_verbose)
  ) |>
  dplyr::arrange(stadium, species) |>
  make_table_display(
    data_table = _,
    cols_id = c("species", "stadium"),
    cols_addon = NULL,
    footnote_data = footnote_base
  ) |> 
  unclass() |> cat()

```


#### Step 3: Indicate cells with higher vs. lower priority


```{r make-filtered-table-illustration}
#| cache: false

table_filtered_illu_list_display <- mapply(
  \(table, index) {
    table |>
      dplyr::arrange(stadium, species) |>
      make_table_display(
        data_table = _,
        cols_id = c("species", "stadium"),
        cols_addon = NULL,
        footnote_data = footnote_filtered[1:index,] |>
          # color last row of footnote
          dplyr::mutate(
            dplyr::across(
              tidyselect::starts_with("scope"),
              \(y) dplyr::case_when(
                dplyr::row_number() == dplyr::n() ~ kableExtra::cell_spec(x = y, color = color_hl),
                TRUE ~ y
              )
            )
          )
      )
  },
  table_filtered_illu_list_upd,
  table_filtered_illu_list_upd |> seq_along(),
  SIMPLIFY = FALSE
)

```


In Step 3, we further filter the base table (i.e., distinguish cells with high vs. low priority). 
To filter, we currently propose to use the following criteria:

- whether or not existing surveillance/monitoring schemes or opportunistic/unstructured observations cover the relevant/feasible scopes
- whether or not the surveillance/monitoring area is known for a species
- whether the expert-judged global feasibility and urgency reaches a critical value

We again explain and illustrate each component of Step 3 in the following.
For the exact filtering rules applied to the survey data see [here](https://github.com/inbo/mias-general/blob/b5c6d5bdccdb77f97c0c42874f5524f57d856ebc/source/export/survey_experts/08_make_priority_tables.R#L293-L340).



##### Existing surveillance/monitoring schemes and opportunistic observations

First, we check whether species-scope combinations can be considered covered by *existing surveillance/monitoring schemes* or *opportunistic/unstructured observations* (i.e., waarnemingen.be).

- Cells for which **existing surveillance schemes meet the respective scope** are marked as having low priority (not yet implemented)
- Cells associated with species for which **opportunistic observations are considered representative** are marked as having low priority

Having considered the representativeness of opportunistic observations the table looks like this:

```{r show-filtered-table-illustration-observation}
#| results: asis
#| classes: .center-table

table_filtered_illu_list_display$observation |> unclass() |> cat()

```

<br>

##### Surveillance/monitoring area being (un-)known

Second, we (again) take into account whether the *surveillance/monitoring area is known* for a species. 
If the area is reported as unknown the following cells are marked as having low priority.

- For **absent species** the detection scope is marked as having low priority if the introduction places are reported as unknown
- For **sporadically present species** the detection scope is marked as having low priority if the introduction places or the distribution area are reported as unknown
- For **limited established species**, if the distribution area is reported as unknown, 
- the distribution- and abundance-related scopes are marked as low priority (conditional on inventory), 
- while the inventory scope is marked as high priority

Having considered whether the surveillance/monitoring area is known the table looks like this:


```{r show-filtered-table-illustration-area}
#| results: asis
#| classes: .center-table

table_filtered_illu_list_display$area |> unclass() |> cat()

```

<br>

##### Global priority score

Finally, we consider the survey’s global priority scores reflecting the *expert-judged global feasibility and urgency per species*. 
For now we calculate these scores as the grand mean across all scored questions per species, which means that each question gets the same weight.

- One (or even multiple) critical value(s) can be defined in an absolute or relative (percentile) manner. 
- Currently, the median is employed as as a critical value(s) 
- Cells associated with species that *do not reach the critical value* are marked as having low priority

Having considered the global prirority score the table looks like this:


```{r show-filtered-table-illustration-globalscore}
#| results: asis
#| classes: .center-table

table_filtered_illu_list_display$score |> unclass() |> cat()

```


#### Step 4: Look for synergies

Finally we aim to *group species based on synergies*. 
For now we consider synergies in *designing* different surveillance/monitoring schemes (e.g., researching methods, planning sampling independent of the concrete sampling sites). We do at this stage not consider synergies that might purely arise during the implementation of the surveillance/monitoring scheme (e.g., overlap in concrete sampling sites). 
We expect the design-synergies to mainly be driven by method overlap between species within scopes. 

Synergies can occur... 

- ... between prior species resulting in groups with multiple prior species,
- ... between prior and non-prior species. In this case we...
- ... indicate non-prior species that are potential ‘free riders’ under surveillance/monitoring schemes for prior species.
- One priority species per group can thereby be sufficient.


Starting from the filtered table...

```{r show-filtered-table-illustration-final}
#| results: asis
#| classes: .center-table

# HERE symbols score disappeared
table_filtered_illu_final <- table_filtered_illu_list_upd |> 
  dplyr::last() |>
  dplyr::mutate(
    # don't highlight symbol
    scope_verbose = gsub(
      color_hl |> grDevices::col2rgb() |> as.vector() |> append(255) |> 
        paste(x = _, collapse = ", "), 
      "black" |> grDevices::col2rgb() |> as.vector() |> append(255) |> 
        paste(x = _, collapse = ", "), 
      scope_verbose)
  ) |>
  dplyr::arrange(stadium, species) 
table_filtered_illu_final |>
  make_table_display(
    data_table = _,
    cols_id = c("species", "stadium"),
    cols_addon = NULL,
    footnote_data = footnote_filtered
  ) |> unclass() |> cat()

```


... we have highlighted method-synergies within the scope distribution.

```{r show-synergies}
#| results: asis
#| classes: .center-table

# FIX symbols score disappeared
table_filtered_illu_final |>
  dplyr::mutate(
    scope_verbose = dplyr::case_when(
      grepl("distribution$", scope_type) & grepl("high", scope_prior) & grepl("methode A", method_all) ~ 
        kableExtra::cell_spec(x = method_all, color = color_meth_a, bold = TRUE),
      grepl("distribution$", scope_type) & grepl("high", scope_prior) & grepl("methode B", method_all) ~ 
        kableExtra::cell_spec(x = method_all, color = color_meth_b, bold = TRUE),
      TRUE ~ scope_verbose
    )
  ) |>
  make_table_display(
    data_table = _,
    cols_id = c("species", "stadium"),
    cols_addon = NULL,
    footnote_data = footnote_filtered
  ) |> unclass() |> cat()

```



## Base tables

```{r sort-base-table}

table_base_upd <- table_base_upd |>
  dplyr::arrange(
    scope_boolean |> dplyr::desc(), 
    scope_type, 
    prius_milieu,
    stadium,
    taxon,
    m_score_feas |> dplyr::desc()
  ) 

``` 

The following base tables for plants and animals are sorted as follows:

- First, rows are sorted by scope type relying on the order of the table columns: `r table_base_upd$scope_type |> levels()`.
- That is, all species for which (at least) detection is relevant/feasible appear first, 
followed by those for which (at least) inventory is relevant/feasible, 
followed by those for which (at least) inventory is relevant/feasible etc., resulting in a stair step (?)/ blocked pattern.
- Within (i.e., for each value of) scope type, rows are sorted by milieu according to the order: `r table_base_upd$prius_milieu |> levels()`.
- Within (i.e., for each value of) milieu, rows are sorted by invasion stadium, from "absent" to "widely established".
- Within (i.e., for each value of) invasion stadium, rows are again sorted by taxon according to the order: `r table_base_upd$taxon |> levels()`.
- Within (i.e., for each value of) taxon, rows are again sorted by feasibility priority score from high to low.

### Plants

```{r make-base-table-display-plants}
#| results: asis
#| cache: false
#| classes: .center-table

table_base_upd |>
  dplyr::filter(grepl("plant", kingdom)) |>
  make_table_display(
    data_table = _,
    cols_id = c("species", "vern_name_nld", "taxon", "on_unionlist", "prius_milieu", "stadium"),
    cols_addon = c("m_score_feas", "m_score_urge"),
    footnote_data = footnote_base
  ) |> unclass() |> cat()

```

### Animals

```{r make-base-table-display-animals}
#| results: asis
#| cache: false
#| classes: .center-table

table_base_upd |>
  dplyr::filter(grepl("dier", kingdom)) |>
  make_table_display(
    data_table = _,
    cols_id = c("species", "vern_name_nld", "taxon", "on_unionlist", "prius_milieu", "stadium"),
    cols_addon = c("m_score_feas", "m_score_urge"),
    footnote_data = footnote_base
  ) |> unclass() |> cat()

```


## Filtered tables


```{r sort-filtered-table}

table_filtered_upd <- table_filtered_upd |>
  dplyr::arrange(
    scope_prior, 
    scope_type, 
    prius_milieu,
    stadium,
    taxon,
    m_score_feas |> dplyr::desc()
  ) 

``` 

The following filtered tables for plants and animals are sorted similarly to the base tables:

- First, rows are sorted by scope priority, with high priority scopes on top.
- Within (i.e., for each value of) scope priority, rows are sorted by scope type relying again on the order: `r table_base_upd$scope_type |> levels()`.
- That is, within the high/low priority scopes, all species for which (at least) detection is relevant/feasible appear first, 
followed by those for which (at least) inventory is relevant/feasible, 
followed by those for which (at least) inventory is relevant/feasible etc..
- Within (i.e., for each value of) scope type, rows are again sorted by milieu according to the order: `r table_base_upd$prius_milieu |> levels()`.
- Within (i.e., for each value of) milieu, rows are again sorted by invasion stadium, from "absent" to "widely established".
- Within (i.e., for each value of) invasion stadium, rows are again sorted by taxon according to the order: `r table_base_upd$taxon |> levels()`.
- Within (i.e., for each value of) taxon, rows are again sorted by feasibility priority score from high to low.



### Plants

```{r make-filtered-table-display-plants}
#| results: asis
#| cache: false
#| classes: .center-table

table_filtered_upd |>
  dplyr::filter(grepl("plant", kingdom)) |>
  make_table_display(
    data_table = _,
    cols_id = c("species", "vern_name_nld", "taxon", "on_unionlist", "prius_milieu", "stadium"),
    cols_addon = c("m_score_feas", "m_score_urge"),
    footnote_data = footnote_combined
  ) |> unclass() |> cat()

```

### Animals

```{r make-filtered-table-display-animals}
#| results: asis
#| cache: false
#| classes: .center-table

table_filtered_upd |>
  dplyr::filter(grepl("dier", kingdom)) |>
  make_table_display(
    data_table = _,
    cols_id = c("species", "vern_name_nld", "taxon", "on_unionlist","prius_milieu", "stadium"),
    cols_addon = c("m_score_feas", "m_score_urge"),
    footnote_data = footnote_combined
  ) |> unclass() |> cat()

```


## Synergies


```{r define-function-prep-data-synergies}
#| warning: false
#| message: false

make_table_syn_list <- function(
    table_filtered,
    cols_addon = c("stadium", "prius_stadium", "taxon", "on_unionlist")
){
  methods <- setNames(
    object = table_filtered$method_all |> unique() |> as.list(),
    nm = table_filtered$method_all |> unique() |> 
      gsub("\\:", "", x = _) |> gsub("\\s", "_", x = _)
  )
  #
  # reshape to dataframe with species list per scope type and method
  table_grouped <- lapply(
    methods,
    function(table, method) {
      table |> 
        tidyr::pivot_wider(
          id_cols = c(scope_type, prius_milieu),
          names_from = method_all,
          values_from = species
        ) |> 
        dplyr::select(
          tidyselect::all_of(c("scope_type", "prius_milieu", method))
        ) |>
        tidyr::unnest(data = _, cols = method) |>
        dplyr::rename(species = method) |> 
        dplyr::mutate(
          method = method,
          n_species = dplyr::n(),
          .by = scope_type
        )
    },
    table = table_filtered
  ) |> 
    dplyr::bind_rows() |>
    dplyr::left_join(
      x = _,
      y = table_filtered |> 
        dplyr::distinct(
          dplyr::across(
            tidyselect::all_of(
              c("species", "vern_name_nld", cols_addon)
            )
          )
        )
    )
  #
  # arrange according to scope_type and n_species in method
  table_grouped <- do.call(
    what = factorize, 
    args = args_factorize |> append(list(dataframe = table_grouped))
  ) |>
    dplyr::arrange(
      scope_type,
      n_species |> dplyr::desc()
    )
  # 
  # reshape to list containing a (species , milieu) x methods data frame per scope 
  scope_type_list <- setNames(
    object = table_grouped$scope_type |> levels() |> as.list(),
    nm = table_grouped$scope_type |> levels()
  )
  table_grouped_list <- lapply(
    scope_type_list, 
    function(scope, table){
      table |> 
        dplyr::filter(scope_type == scope) |>
        tidyr::pivot_wider(
          id_cols = c("scope_type", "species", "vern_name_nld", "prius_milieu", cols_addon),
          names_from = method,
          names_prefix = "method_",
          values_from = n_species
        )
    },
    table = table_grouped
  )
  
}


```

```{r define-functions-make-table-synergies-display}

make_table_syn_display_prep <- function(
    table,
    cols_id = c("species", "vern_name_nld", "taxon", "on_unionlist", "stadium", "prius_stadium", "prius_milieu"),
    color = color_hl
) {
  table_prep <- table |>
    dplyr::select(tidyselect::all_of(cols_id), tidyselect::starts_with("method_"))
  # move number of species to added last row
  added_row <- table_prep |> 
    tibble::add_row(.before = 1) |>
    tidyr::fill(tidyselect::starts_with("method_"), .direction = "downup") |>
    dplyr::mutate(
      dplyr::across(
        tidyselect::starts_with("method_"), paste0
      )
    ) |> 
    dplyr::slice(1) |>
    dplyr::mutate(
      species = kableExtra::cell_spec(
        x = "Number of species covered",
        italic = TRUE
      )
    ) 
  table_prep <- table_prep |>
    dplyr::arrange(
      prius_milieu,
      taxon
      ) |>
    dplyr::mutate(
      dplyr::across(
        tidyselect::starts_with("method_"),
        \(x) dplyr::case_when(
          !is.na(x) ~ kableExtra::cell_spec(
            x = " ",
            background = color,
            # fill entire cell (4px )
            extra_css = paste(
              "margin: -4px",
              "padding: 8px",
              "display: flex",
              NULL,
              sep = "; "
            )
          ),
          TRUE ~ NA_character_
        )
      )
    )
  if (nrow(table_prep) > 0){
    table_prep <- table_prep |>
      dplyr::bind_rows(x = _, y = added_row)
  }
}
make_table_syn_display <- function(
    table_prior,
    table_secondary,
    cols_id = c("species", "vern_name_nld", "taxon", "on_unionlist", "stadium", "prius_stadium", "prius_milieu")
) {
  # combine tables
  table_comb <- if (!is.null(table_secondary)) {
    dplyr::bind_rows(table_prior, table_secondary)
  } else {
    table_prior
  }
  
  # update column names (not rotate the id_cols)
  colnames_upd <- c(
    colnames(table_comb)[seq_along(cols_id)] |> kableExtra::cell_spec(
      x = _,
      extra_css = "writing-mode: horizontal-tb !important;  transform: rotate(180deg) !important;"
    ),
    colnames(table_comb)[(length(cols_id) + 1): ncol(table_comb)] |> 
      gsub(pattern = "method_", replacement = "", x = _)
  )
  #
  #
  table_comb |>
    knitr::kable(
      x = _,
      format = "html",
      escape = FALSE,
      col.names = colnames_upd,
      table.attr = 'data-quarto-disable-processing="true"' # if quarto HERE
    ) |>
    # background of id cols
    kableExtra::column_spec(
      column = seq_along(cols_id),
      background = "grey97",
      #width_min = "220px",
      extra_css = "white-space: nowrap;"
    ) |>
    # borders of method cols
    #  width
    kableExtra::column_spec(
      column = (length(cols_id) + 1):ncol(table_comb),
      width_min = "20px",
      width_max = "20px",
      include_thead = TRUE,
      border_right = "2px solid #f7f7f7"
    ) |>
    kableExtra::kable_styling(
      bootstrap_options = c("condensed", "hover"), # "responsive"
      full_width = FALSE,
      position = "left",
      font_size = 11
    ) |>
    kableExtra::collapse_rows(
      columns = seq_along(cols_id),
      valign = "top"
    ) |>
    kableExtra::add_header_above(
      header = c(
        " " = length(cols_id),
        "method" = ncol(table_comb) - length(cols_id)
      ),
      extra_css = "border-bottom: 1.5px solid"
    ) |>
    # rotate column names pertaining to methods
    kableExtra::row_spec(
      row = 0,
      extra_css = 
        "writing-mode: vertical-lr;  transform: rotate(180deg); white-space: nowrap; padding: 5px;"
    ) |>
    # adjust row height
    kableExtra::row_spec(
      row = 1:nrow(table_comb),
      extra_css = 'padding: 4px;'
    ) |>
    # uncolor summary rows
    kableExtra::row_spec(
      row = c(nrow(table_prior), nrow(table_comb)),
      background = "white"
    ) |>
    kableExtra::group_rows(
      group_label = "Primary species",
      start_row = 1,
      end_row = nrow(table_prior)
    ) |>
    (\(x)
     if (!is.null(table_secondary)) {
       x |>
         kableExtra::group_rows(
           group_label = "Secondary species",
           start_row = nrow(table_prior) + 1,
           end_row = nrow(table_comb)
         )
     } else {
       x
       }
    )()
}


```


Per surveillance/monitoring scope, the following tables reveal method-related synergies between species.
If a species is covered by one of the methods reported for the respective scope, the table cell is filled and the total number of species covered by that method is displayed.

We might use these tables to identify the x largest species groups covered by the same method within similar habitats.
For these x groups we could proceed with the detailed planning of surveillance/monitoring schemes.

Once we have identified x high-priority species groups to tackle, we can search for method-related synergies between the chosen high-priority and low-priority species.



### Plants


```{r synergies-plants-make-tables}
#| warning: false
#| message: false
#| cache: false

table_plants_prior_list <- make_table_syn_list(
  table_filtered = table_filtered_upd |> 
    dplyr::filter(
      grepl("plant", kingdom) & 
        grepl("highprior", scope_prior) 
    )
) |>
  lapply(
    X = _,
    FUN = make_table_syn_display_prep
  )
table_plants_secondary_list <- make_table_syn_list(
  table_filtered = table_filtered_upd |> 
    dplyr::filter(
      grepl("plant", kingdom) & 
        grepl("lowprior", scope_prior) &
        scope_prior_motivation == "scope low priority as feasibility score is larger but urgency score is smaller than cutoff"
    )
) |>
  lapply(
    X = _,
    FUN = make_table_syn_display_prep,
    color = "gray"
  )
tmp <- vctrs::list_drop_empty(table_plants_prior_list)
scope_type_list_plants <- setNames(
  object = tmp |> names() |> as.list(),
  nm = tmp |> names() 
)
table_grouped_plants_display_list <- lapply(
  scope_type_list_plants,
  \(x) make_table_syn_display(
    table_prior = table_plants_prior_list[[x]],
    table_secondary = table_plants_secondary_list[[x]]
  )
)

```


#### Scope detection


```{r synergies-plants-display-detection}
#| results: asis
#| cache: false
#| eval: true

table_grouped_plants_display_list$detection 

```

<br>



#### Scope distribution

```{r synergies-plants-display-distribution}
#| results: asis
#| cache: false
#| classes: .center-table
#| eval: true

table_grouped_plants_display_list$distribution

```


<br>

#### Scope abundance

```{r synergies-plants-display-abundance}
#| results: asis
#| cache: false
#| classes: .center-table
#| eval: true

table_grouped_plants_display_list$abundance

```


<br>

#### Scope distribution after management

```{r synergies-plants-display-distribution-management}
#| results: asis
#| cache: false
#| classes: .center-table
#| eval: true

table_grouped_plants_display_list$distribution_management

```


<br>

#### Scope abundance after management

```{r synergies-plants-display-abundance-management}
#| results: asis
#| cache: false
#| classes: .center-table
#| eval: true

table_grouped_plants_display_list$abundance_management

```

<br>




### Animals



```{r synergies-animals-make-tables}
#| warning: false
#| message: false
#| cache: false


table_animals_prior_list <- make_table_syn_list(
  table_filtered = table_filtered_upd |> 
    dplyr::filter(
      grepl("dier", kingdom) & 
        grepl("highprior", scope_prior) 
    )
) |>
  lapply(
    X = _,
    FUN = make_table_syn_display_prep
  )
table_animals_secondary_list <- make_table_syn_list(
  table_filtered = table_filtered_upd |> 
    dplyr::filter(
      grepl("dier", kingdom) & 
        grepl("lowprior", scope_prior) &
        scope_prior_motivation == "scope low priority as feasibility score is larger but urgency score is smaller than cutoff"
    )
) |>
  lapply(
    X = _,
    FUN = make_table_syn_display_prep,
    color = "gray"
  )
tmp <- vctrs::list_drop_empty(table_animals_prior_list)
scope_type_list_animals <- setNames(
  object = tmp |> names() |> as.list(),
  nm = tmp |> names() 
)
table_grouped_animals_display_list <- lapply(
  scope_type_list_animals,
  \(x) make_table_syn_display(
    table_prior = table_animals_prior_list[[x]],
    table_secondary = table_animals_secondary_list[[x]]
  )
)

```




#### Scope detection


```{r synergies-animals-display-detection}
#| results: asis
#| cache: false
#| eval: true

table_grouped_animals_display_list$detection 

```

<br>

#### Scope inventory

```{r synergies-animals-display-inventory}
#| results: asis
#| cache: false
#| classes: .center-table
#| eval: true

table_grouped_animals_display_list$inventory

```


<br>

#### Scope distribution

```{r synergies-animals-display-distribution}
#| results: asis
#| cache: false
#| classes: .center-table
#| eval: true

table_grouped_animals_display_list$distribution

```


<br>

#### Scope abundance

```{r synergies-animals-display-abundance}
#| results: asis
#| cache: false
#| classes: .center-table
#| eval: true

table_grouped_animals_display_list$abundance

```


<br>

#### Scope distribution after management

```{r synergies-animals-display-distribution-management}
#| results: asis
#| cache: false
#| classes: .center-table
#| eval: true

table_grouped_animals_display_list$distribution_management

```


<br>

#### Scope abundance after management

```{r synergies-animals-display-abundance-management}
#| results: asis
#| cache: false
#| classes: .center-table
#| eval: true

table_grouped_animals_display_list$abundance_management

```

<br>



